<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AlphaTab Guitar Practice Player (Top Controls, Note Highlight, MIDI→TAB)</title>
  <style>
    :root{--bg:#0b1220;--fg:#e7f0ff;--muted:#a6b7d1;--panel:#101a2a;--panel2:#0e1830;--border:#1d2946;--accent:#4aa3ff;--accent2:#7bd88f;}
    html,body{height:100%} body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    header{background:#0f1a2f;border-bottom:1px solid var(--border);padding:10px 14px;display:flex;gap:6px;align-items:center;flex-wrap:wrap;position:sticky;top:0;z-index:5}
    header h2{margin:0;font-size:16px}
    .btn{padding:8px 12px;border-radius:10px;border:1px solid var(--border);background:#172544;color:var(--fg);cursor:pointer}
    .btn[disabled]{opacity:.6;cursor:not-allowed}
    .chip{padding:6px 10px;border-radius:999px;background:#0f203b;border:1px solid var(--border);color:var(--muted)}
    select,input[type="file"]{padding:8px;border-radius:10px;border:1px solid var(--border);background:#0f1a2f;color:var(--fg)}
    .wrap{display:grid;grid-template-columns:280px 1fr;gap:0;min-height:calc(100% - 58px)}
    .sidebar{background:var(--panel2);border-right:1px solid var(--border);overflow:auto}
    .sidebar h3{margin:10px 12px;color:var(--muted);font-size:14px}
    .main{display:flex;flex-direction:column}
    #alphaTab{flex:1;min-height:420px;background:white;border-bottom:1px solid var(--border);overflow:auto}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .slider{appearance:none;height:6px;background:#14264a;border-radius:8px}
    .slider::-webkit-slider-thumb{appearance:none;width:16px;height:16px;border-radius:50%;background:var(--accent)}
    .track{display:flex;gap:10px;align-items:center;padding:8px;border-bottom:1px dashed #15264a}
    .track .name{font-size:13px;line-height:1.2} .track .name small{display:block;color:#8ea1c5}
    .log{max-height:160px;overflow:auto;background:#0b1428;border-top:1px solid var(--border);padding:6px 8px;font-family:ui-monospace,Consolas,Menlo,monospace;color:#9db2d8}
    a.link{color:#9ecbff}
    .at-cursor-bar{background:rgba(255,242,0,.22)}
    .at-cursor-beat{background:rgba(64,255,160,.95);width:5px}
    .at-highlight *{fill:#00a2ff;stroke:#00a2ff}
    .at-selection *{fill:#ffd166;stroke:#ffd166}
  
header{flex-wrap:nowrap;gap:6px;overflow-x:auto}
header h2{font-size:14px;white-space:nowrap}
header .btn{font-size:12px;padding:6px 10px;border-radius:8px}
header .chip{font-size:11px;padding:4px 8px}
header select, header input[type="file"]{font-size:12px;padding:6px 8px}
header .link{font-size:11px}

  
/* Sidebar (left panel) compaction */
.sidebar{font-size:12px}
.sidebar h3{font-size:13px;margin:4px 0 8px}
.sidebar .btn{font-size:12px;padding:6px 10px;border-radius:8px}
.sidebar select,.sidebar input,.sidebar .chip,.sidebar label,.sidebar .link{font-size:12px}

  
/* Smaller top-panel title */
header h2{font-size:13px !important}

  
/* Hide the MIDI→MusicXML converter section in the left panel */
.hide-left-section{display:none !important}

  
/* Keep content clear of the sticky header if any element tries to scroll into view */
html, body { scroll-padding-top: 72px; }
.at-content { scroll-padding-top: 72px; }

  
/* Provide headroom so autoscroll can't tuck staves under the sticky header */
#alphaTab.at-content { padding-top: 76px; }
#alphaTab.at-content * { scroll-margin-top: 76px; }

  
/* Active button highlight */
.btn.active{background:var(--accent);color:#08101f;box-shadow:0 0 0 2px var(--accent) inset, 0 0 8px rgba(74,163,255,.35)}
.sidebar .btn.active{background:var(--accent2);color:#08101f;box-shadow:0 0 0 2px var(--accent2) inset, 0 0 8px rgba(123,216,143,.35)}

  
/* Make top-panel Count-In & Metronome match Instruments' active color */
header #countIn.btn.active,
header #metronome.btn.active {
  background: var(--accent2);
  color: #08101f;
  box-shadow: 0 0 0 2px var(--accent2) inset, 0 0 8px rgba(123,216,143,.35);
}

  
/* Use the same active highlight in the header as in the sidebar */
header .btn.active{background:var(--accent2);color:#08101f;box-shadow:0 0 0 2px var(--accent2) inset,0 0 8px rgba(123,216,143,.35)}

  
/* Keep header visible; give the app its own scroll areas */
html, body { height: 100%; overflow: hidden; }
header { position: sticky; top: 0; z-index: 5; }
.wrap { height: calc(100vh - 58px); }            /* match prior header height */
.sidebar { height: 100%; overflow: auto; }
#alphaTab.at-content { height: 100%; overflow: auto; padding-top: 76px; }
#alphaTab.at-content * { scroll-margin-top: 76px; }

  
/* Ensure the grid and main fill the viewport, and alphaTab scrolls */
.wrap { height: calc(100vh - 58px) !important; }
.main { height: 100% !important; overflow: hidden; }
#alphaTab.at-content { height: 100% !important; overflow: auto !important; touch-action: pan-y; overscroll-behavior: contain; }

  
/* Highlight instruments currently sounding */
#tracks .track.playing { 
  background: rgba(123,216,143,0.18);
  outline: 2px solid var(--accent2);
  border-radius: 10px;
}

  
/* Stronger "now playing" highlight for instruments */
#tracks .track.playing {
  background: rgba(123,216,143,0.22) !important;
  box-shadow: 0 0 0 2px var(--accent2) inset, 0 0 14px rgba(123,216,143,.45);
  border-radius: 12px;
}

  
/* Subtle, thinner "now playing" style */
#tracks .track.playing {
  background: rgba(123,216,143,0.12) !important;
  box-shadow: 0 0 0 1px var(--accent2) inset, 0 0 6px rgba(123,216,143,.25) !important;
  border-radius: 12px;
  transition: background .15s ease, box-shadow .15s ease;
}

  
/* --- Hide AlphaTab brand watermark --- */
#alphaTab .at-brand,
#alphaTab text.at-brand,
#alphaTab g.at-brand,
#alphaTab [class*="at-brand"],
#alphaTab [data-brand],
#alphaTab [data-alpha-tab-brand] {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
}

</style>

  <!-- AlphaTab & @tonejs/midi -->
  <script src="https://cdn.jsdelivr.net/npm/@coderline/alphatab@1.6.1/dist/alphaTab.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.28/build/Midi.js"></script>
</head>
<body>
  <header>
    <h2>Upkraft</h2>
    <input id="fileInput" type="file" accept=".gp,.gp3,.gp4,.gp5,.gp6,.gp7,.gp8,.gpx,.xml,.musicxml,.mxl,.cap,.capx,.mid,.midi" />
<button class="btn" id="play">▶ Play</button>
    <button class="btn" id="pause">⏸ Pause</button>
    <button class="btn" id="stop">⏹ Stop</button>
    <label class="chip">Speed
      <select id="speed">
        <option value="0.5">50%</option><option value="0.75">75%</option>
        <option value="1" selected>100%</option><option value="1.25">125%</option><option value="1.5">150%</option>
      </select>
    </label>
    <label class="chip"><input type="checkbox" id="autoScroll" checked> Auto‑Scroll</label>
    <button class="btn" id="countIn">Count‑In</button>
    <button class="btn" id="metronome">Metronome</button>
    <span class="chip">Loop A/B: <a href="#" class="link" id="setA">Set A</a> • <a href="#" class="link" id="setB">Set B</a> • <a href="#" class="link" id="clearAB">Clear</a></span>
    <span id="ab" class="chip">A: — | B: —</span>
    <span id="time" class="chip">00:00 / 00:00</span>
    <span id="meta" class="chip">No score loaded</span>
  </header>

  <div class="wrap">
    <aside class="sidebar">
      <h3>Instruments (render / solo / mute)</h3>
      <div id="tracks"></div>
      <div class="hide-left-section">
<h3>MIDI → MusicXML (for TAB)</h3>
      <div style="padding:8px; display:grid; gap:8px">
        <label class="chip">Quantize
          <select id="quant"><option>4</option><option selected>8</option><option>12</option><option>16</option><option>24</option><option>32</option></select>
        </label>
        <label class="chip">Time Sig
          <select id="tsNum"><option>2</option><option>3</option><option selected>4</option><option>6</option><option>7</option><option>9</option><option>12</option></select> /
          <select id="tsDen"><option>1</option><option>2</option><option selected>4</option><option>8</option><option>16</option></select>
        </label>
        <label><input type="checkbox" id="merge" /> Merge all tracks</label>
        <label><input type="checkbox" id="includePerc" /> Include percussion (Ch.10)</label>
      </div>
      <div class="log" id="log"></div>
    
</div>
</aside>

    <main class="main">
      <div id="alphaTab" class="at-content"></div>
    </main>
  </div>

<script>
const $ = s => document.querySelector(s);
const logEl = $('#log'); function log(m){ const d=document.createElement('div'); d.textContent=m; logEl.appendChild(d); logEl/* auto-scroll disabled (scrollTop) */; console.log(m); }

// Init AlphaTab
const at = new alphaTab.AlphaTabApi($('#alphaTab'), {
  player: {
    enablePlayer: true,
    enableCursor: true,
    enableScrolling: true,
    soundFont: "https://cdn.jsdelivr.net/npm/@coderline/alphatab@1.6.1/dist/soundfont/sonivox.sf2"
  },
  display: {
    staveProfile: alphaTab.StaveProfile.ScoreTab, // notation + TAB
    layoutMode: alphaTab.LayoutMode.Page
  }
});
window.at = at;

// Transport
$('#play').onclick = ()=> at.play();
$('#pause').onclick = ()=> at.pause();
$('#stop').onclick = ()=> at.stop();
$('#speed').onchange = e => at.playbackSpeed = parseFloat(e.target.value);
$('#countIn').onclick = ()=> at.countInVolume = at.countInVolume > 0 ? 0 : 1;
$('#metronome').onclick = ()=> at.metronomeVolume = at.metronomeVolume > 0 ? 0 : 1;

// A/B Loop
let aTick=null,bTick=null;
function updateAB(){
  $('#ab').textContent = `A: ${aTick??'—'} | B: ${bTick??'—'}`;
  if(aTick!=null && bTick!=null){
    const startTick = Math.min(aTick,bTick), endTick = Math.max(aTick,bTick);
    at.playbackRange = { startTick, endTick }; at.isLooping = true;
  } else { at.playbackRange = null; at.isLooping = false; }
}
$('#setA').onclick = e=>{ e.preventDefault(); aTick = at.tickPosition|0; updateAB(); };
$('#setB').onclick = e=>{ e.preventDefault(); bTick = at.tickPosition|0; updateAB(); };
$('#clearAB').onclick = e=>{ e.preventDefault(); aTick=bTick=null; updateAB(); };

// Time display
at.playerPositionChanged.on(e=>{
  const fmt = ms => { const s=Math.floor(ms/1000), m=(s/60|0), ss=String(s%60).padStart(2,'0'); return `${m}:${ss}`; };
  $('#time').textContent = `${fmt(e.currentTime)} / ${fmt(e.endTime)}`;
});

// Extra highlight of current element
at.midiEventsPlayedFilter = [alphaTab.midi.MidiEventType.NoteOn];
at.midiEventsPlayed.on(ev => {
  const el = ev?.events?.[0]?.element;
  if (el && at.setSelection) {
    try { at.setSelection([el]); } catch { /* ignore if not supported */ }
  }
});

// Track list
function renderTrackList(score){
  const cont = $('#tracks'); cont.innerHTML='';
  (score.tracks||[]).forEach((t, idx)=>{
    const row = document.createElement('div');
    row.className = 'track';
    row.innerHTML = `
      <div class="name"><strong>${t.name||('Track '+(idx+1))}</strong><small>${t.isPercussion?'Percussion':'Instrument'}</small></div>
      <div style="margin-left:auto; display:flex; gap:6px; align-items:center">
        <label title="Render this track"><input type="checkbox" class="render"></label>
        <button class="btn solo">Solo</button>
        <button class="btn mute">Mute</button>
      </div>`;
    const renderCb = row.querySelector('.render');
    renderCb.addEventListener('change', ()=>{
      const selected = [...document.querySelectorAll('.track .render:checked')].map(cb=>{
        const i = [...cont.children].indexOf(cb.closest('.track'));
        return at.score.tracks[i];
      });
      if(selected.length===0){ at.renderTracks([at.score.tracks[0]]); cont.querySelector('.track .render').checked = true; }
      else { at.renderTracks(selected); }
    });
    row.querySelector('.solo').onclick = ()=> at.changeTrackSolo([at.score.tracks[idx]], true);
    row.querySelector('.mute').onclick = ()=> at.changeTrackMute([at.score.tracks[idx]], true);
cont.appendChild(row);
  });
  if(at.score.tracks?.length){ at.renderTracks([at.score.tracks[0]]); document.querySelector('.track .render').checked = true; }
}
at.scoreLoaded.on(score=>{
  $('#meta').textContent = `${score.title||'Untitled'} — ${score.artist||'Unknown'} (${score.tracks?.length||0} tracks)`;
  renderTrackList(score);
});

// File input
$('#fileInput').addEventListener('change', async e=>{
  const f = e.target.files?.[0]; if(!f) return;
  const name = f.name.toLowerCase(); const buf = await f.arrayBuffer();
  if(name.endsWith('.mid') || name.endsWith('.midi')){
    try{
      const xml = midiToMusicXmlWithTab(new Midi(buf), {
        quant: parseInt($('#quant').value,10)||8,
        tsNum: parseInt($('#tsNum').value,10)||4,
        tsDen: parseInt($('#tsDen').value,10)||4,
        merge: $('#merge').checked,
        includePerc: $('#includePerc').checked
      });
      const blob = new Blob([xml], {type:'application/vnd.recordare.musicxml+xml'});
      await at.load(await blob.arrayBuffer());
      log('Converted MIDI → MusicXML with TAB and loaded.');
    }catch(err){
      log('MIDI conversion failed: '+err.message);
      alert('Could not convert MIDI. Try a different quantization/time signature, or export MusicXML from your DAW.');
    }
  } else {
    try{ await at.load(buf); log('Loaded: '+f.name); }catch(err){ log('Load error: '+err.message); }
  }
});

// --- MIDI → MusicXML (two staves: treble + TAB) ---
function midiToMusicXmlWithTab(midi, opts){
  const ppq = midi.header.ppq || 480;
  const divisions = opts.quant || 8;
  const tsN = opts.tsNum || 4, tsD = opts.tsDen || 4;
  const includePerc = !!opts.includePerc;
  const merge = !!opts.merge;
  const bpm = (midi.header.tempos && midi.header.tempos[0] && midi.header.tempos[0].bpm) ? Math.round(midi.header.tempos[0].bpm) : 120;

  // Standard guitar tuning: strings 1..6 = E4,B3,G3,D3,A2,E2
  const tuningMidi = [64,59,55,50,45,40];

  // Build parts (skip empty/percussion unless opted-in)
  const parts=[];
  if(merge){
    const all=[];
    midi.tracks.forEach((t,ti)=>{
      const ch = (typeof t.channel==='number') ? t.channel : null;
      if(!includePerc && ch===9) return;
      (t.notes||[]).forEach(n=> all.push({...n, track:ti}));
    });
    parts.push({id:'P1', name:'Merged', notes:all});
  } else {
    let idx=1;
    midi.tracks.forEach((t,ti)=>{
      if(!t.notes || !t.notes.length) return;
      const ch = (typeof t.channel==='number') ? t.channel : null;
      if(!includePerc && ch===9) return;
      parts.push({id:'P'+(idx++), name: t.name||('Track '+(ti+1)), notes:t.notes.slice()});
    });
  }

  function qTicksToDiv(ticks){ return Math.max(1, Math.round((ticks/ppq)*divisions)); }
  function midiToPitch(m){
    const names=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]; const sFull=names[m%12];
    const step=sFull.replace('#',''); const alter=sFull.includes('#')?1:0; const octave=(m/12|0)-1;
    return {step, alter, octave};
  }
  function durationType(divs){
    const ratio = divs/divisions; const map={4:'whole',2:'half',1:'quarter',0.5:'eighth',0.25:'16th',0.125:'32nd'};
    for(const k of Object.keys(map)){ if(Math.abs(ratio-parseFloat(k))<1e-6) return map[k]; } return null;
  }
  const measDiv = Math.round(divisions * tsN * (4/tsD));

  function quantize(notes){
    return notes.map(n=>({start:qTicksToDiv(n.ticks), dur:Math.max(1,qTicksToDiv(n.durationTicks)), midi:n.midi|0})).sort((a,b)=>a.start-b.start||a.midi-b.midi);
  }
  function splitMeasures(qnotes){
    const measures=[]; let i=0;
    while(i<qnotes.length){
      const s=qnotes[i].start; const batch=[];
      while(i<qnotes.length && qnotes[i].start===s){ batch.push(qnotes[i]); i++; }
      const dur = Math.max(...batch.map(x=>x.dur));
      let pos=s, remaining=dur;
      while(remaining>0){
        const mIndex = Math.floor(pos/measDiv); const mStart=mIndex*measDiv;
        const within = pos - mStart; const room = measDiv - within; const take = Math.min(remaining, room);
        if(!measures[mIndex]) measures[mIndex]=[];
        measures[mIndex].push({ offset: within, dur: take, midis: batch.map(x=>x.midi), tieStart: remaining>take, tieStop: within>0 && take<dur });
        pos+=take; remaining-=take;
      }
    }
    return measures;
  }

  function toStringFret(m){
    let bestFret = Infinity, bestString = 1;
    for(let s=0;s<6;s++){
      const fret = m - tuningMidi[s];
      if(fret>=0 && fret<=22){
        if(fret < bestFret){ bestFret=fret; bestString = s+1; }
      }
    }
    if(!isFinite(bestFret)){ const f = Math.max(0, m - tuningMidi[0]); return {string:1, fret:f}; }
    return {string:bestString, fret:bestFret};
  }

  function escapeXml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  function tuningStaffDetails(){
    function stepOct(m){ const names=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]; const name=names[m%12]; const step=name.replace('#',''); const oct=(m/12|0)-1; return {step,oct:oct}; }
    let lines = ['      <staff-details number="2"><staff-lines>6</staff-lines><staff-type>tab</staff-type>'];
    for(let i=0;i<6;i++){
      const {step,oct} = stepOct(tuningMidi[i]);
      lines.push(`        <staff-tuning line="${i+1}"><tuning-step>${step}</tuning-step><tuning-octave>${oct}</tuning-octave></staff-tuning>`);
    }
    lines.push('      </staff-details>');
    return lines.join('\n');
  }

  function emitHeader(){
    const title = midi.name ? escapeXml(midi.name) : 'MIDI Conversion';
    return [
      '<?xml version="1.0" encoding="UTF-8" standalone="no"?>',
      '<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">',
      '<score-partwise version="3.1">',
      `  <work><work-title>${title}</work-title></work>`,
      '  <identification><encoding><software>MIDI→MusicXML (client-side, with TAB)</software></encoding></identification>',
      '  <part-list>',
      ...parts.map(p=>`    <score-part id="${p.id}"><part-name>${escapeXml(p.name)}</part-name></score-part>`),
      '  </part-list>'
    ].join('\n');
  }

  function emitAttributes(){
    return [
      '      <attributes>',
      `        <divisions>${divisions}</divisions>`,
      '        <staves>2</staves>',
      '        <clef number="1"><sign>G</sign><line>2</line></clef>',
      '        <clef number="2"><sign>TAB</sign><line>5</line></clef>',
      `        <time><beats>${tsN}</beats><beat-type>${tsD}</beat-type></time>`,
      tuningStaffDetails(),
      '      </attributes>',
      `      <direction placement="above"><direction-type><metronome><beat-unit>quarter</beat-unit><per-minute>${bpm}</per-minute></metronome></direction-type><sound tempo="${bpm}"/></direction>`
    ].join('\n');
  }

  function emitPart(p){
    const q = quantize(p.notes||[]);
    const measures = splitMeasures(q);
    let xml = `  <part id="${p.id}">\n`;
    const lastPos = q.length ? (q[q.length-1].start + q[q.length-1].dur) : 0;
    const totalMeasures = measures.length ? measures.length : (lastPos ? Math.ceil(lastPos / measDiv) : 1);
    for(let mi=0; mi<totalMeasures; mi++){
      xml += `    <measure number="${mi+1}">\n`;
      if(mi===0) xml += emitAttributes() + '\n';

      const raw = measures[mi] || [];
      const entries = raw.length ? raw.slice().sort((a,b)=>a.offset-b.offset) : [];
      let j=0;
      while(j<entries.length){
        const off = entries[j].offset; const group=[];
        while(j<entries.length && entries[j].offset===off){ group.push(entries[j]); j++; }
        const chord = [...new Set(group.flatMap(g=>g.midis))].sort((a,b)=>a-b);
        const dur = Math.max(...group.map(g=>g.dur));
        const tieStart = group.some(g=>g.tieStart), tieStop = group.some(g=>g.tieStop);

        if (chord.length===0){
          xml += '      <note>\n        <rest/>\n';
          xml += `        <duration>${dur}</duration>\n        <voice>1</voice>\n        <staff>1</staff>\n`;
          const typ = durationType(dur); if (typ) xml += `        <type>${typ}</type>\n`;
          xml += '      </note>\n';
        } else {
          // Staff 1 (notation)
          chord.forEach((m, idx)=>{
            const pch = midiToPitch(m);
            xml += '      <note>\n';
            if (idx>0) xml += '        <chord/>\n';
            xml += `        <pitch><step>${pch.step}</step>${pch.alter?`<alter>${pch.alter}</alter>`:''}<octave>${pch.octave}</octave></pitch>\n`;
            xml += `        <duration>${dur}</duration>\n        <voice>1</voice>\n        <staff>1</staff>\n`;
            const typ = durationType(dur); if (typ) xml += `        <type>${typ}</type>\n`;
            if (tieStop)  xml += '        <tie type="stop"/>\n';
            if (tieStart) xml += '        <tie type="start"/>\n';
            if (tieStop || tieStart){ xml += '        <notations>'; if(tieStop) xml += '<tied type="stop"/>'; if(tieStart) xml += '<tied type="start"/>'; xml += '</notations>\n'; }
            xml += '      </note>\n';
          });
          // Staff 2 (TAB) with string/fret
          chord.forEach((m, idx)=>{
            const pch = midiToPitch(m);
            const sf = toStringFret(m);
            xml += '      <note>\n';
            if (idx>0) xml += '        <chord/>\n';
            xml += `        <pitch><step>${pch.step}</step>${pch.alter?`<alter>${pch.alter}</alter>`:''}<octave>${pch.octave}</octave></pitch>\n`;
            xml += `        <duration>${dur}</duration>\n        <voice>2</voice>\n        <staff>2</staff>\n`;
            const typ = durationType(dur); if (typ) xml += `        <type>${typ}</type>\n`;
            if (tieStop)  xml += '        <tie type="stop"/>\n';
            if (tieStart) xml += '        <tie type="start"/>\n';
            xml += `        <notations><technical><string>${sf.string}</string><fret>${sf.fret}</fret></technical>`;
            if (tieStop)  xml += '<tied type="stop"/>';
            if (tieStart) xml += '<tied type="start"/>';
            xml += '</notations>\n';
            xml += '      </note>\n';
          });
        }
      }
      xml += '    </measure>\n';
    }
    xml += '  </part>\n';
    return xml;
  }

  let out = emitHeader() + '\n';
  for(const p of parts) out += emitPart(p);
  out += '</score-partwise>';
  return out;
}

// Live per-instrument highlight based on NoteOn events
(function(){
  const timers = {};
  function rows(){ return Array.from(document.querySelectorAll('#tracks .track')); }
  function clearAllPlaying(){
    rows().forEach(r=> r.classList.remove('playing'));
    for (const k in timers){ clearTimeout(timers[k]); delete timers[k]; }
  }
  function trackIndexFromElement(el){
    try {
      const t = el?.beat?.voice?.track || el?.voice?.track || el?.staff?.track || el?.track || null;
      if (!t) return null;
      const idx = (at.score.tracks||[]).indexOf(t);
      return idx >= 0 ? idx : null;
    } catch { return null; }
  }
  // Highlight on NoteOn
  at.midiEventsPlayed.on(ev => {
    const seen = new Set();
    (ev?.events||[]).forEach(me=>{
      const el = me?.element;
      const idx = trackIndexFromElement(el);
      if (idx == null) return;
      seen.add(idx);
      const r = rows()[idx]; if (!r) return;
      r.classList.add('playing');
      if (timers[idx]) clearTimeout(timers[idx]);
      timers[idx] = setTimeout(()=>{
        const rr = rows()[idx];
        if (rr) rr.classList.remove('playing');
        delete timers[idx];
      }, 180);
    });
  });
  // Also sync with player state
  try {
    at.player.stateChanged?.on?.((s)=>{
      if (s !== 1) clearAllPlaying(); // not playing
    });
  } catch{}
  // After list re-render, clear stale timers & classes
  const oldRender = window.renderTrackList;
  window.renderTrackList = function(score){
    if (typeof oldRender === 'function') oldRender(score);
    clearAllPlaying();
  };
})();    
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const aside = document.querySelector('aside.sidebar');
  if (!aside) return;
  // Create (or reuse) a hidden parking area to preserve elements for JS bindings
  let park = document.getElementById('ui-parking');
  if (!park) {
    park = document.createElement('div');
    park.id = 'ui-parking';
    park.style.display = 'none';
    document.body.appendChild(park);
  }
  // Keep only the heading and the #tracks container in the sidebar
  const kids = Array.from(aside.children);
  for (const el of kids) {
    const id = (el.getAttribute && el.getAttribute('id')) || '';
    if (el.tagName.toLowerCase() === 'h3') continue;
    if (id === 'tracks') continue;
    park.appendChild(el);
  }
  // Rename sidebar title
  const h = aside.querySelector('h3');
  if (h) h.textContent = 'Instruments';
});
</script>


<script>
// Hard stop: suppress programmatic auto-scrolling at runtime
(function(){
  const blockScroll = (e)=>{
    try {
      if (!e) return;
      const t = e.target || e.currentTarget || document;
      if (t && (t.scrollLeft || t.scrollTop)) {
        t.scrollLeft = t.scrollLeft; // no-op
        t.scrollTop = t.scrollTop;   // no-op
      }
    } catch(_){}
  };
  // Monkey-patch common scroll methods
  const elProto = Element.prototype;
  const origSIV = elProto.scrollIntoView;
  if (origSIV) {
    elProto.scrollIntoView = function(){ /* disabled */ };
  }
  const origScrollTo = window.scrollTo;
  if (origScrollTo) {
    window.scrollTo = function(){ /* disabled */ };
  }
  const origScrollBy = window.scrollBy;
  if (origScrollBy) {
    window.scrollBy = function(){ /* disabled */ };
  }
  // Prevent smooth scrolling CSS from re-enabling movement
  document.documentElement.style.scrollBehavior = 'auto';
})();
</script>




<script>
(function(){
  function setTop(){
    try {
      const se = document.scrollingElement || document.documentElement || document.body;
      se.scrollTop = 0; se.scrollLeft = 0;
    } catch(_){}
    try {
      const aside = document.querySelector('aside.sidebar');
      if (aside) { aside.scrollTop = 0; }
    } catch(_){}
  }
  function freeze(ms=900){
    const until = Date.now() + ms;
    const id = setInterval(()=>{
      if (Date.now() > until) return clearInterval(id);
      setTop();
    }, 16);
  }
  window.addEventListener('load', ()=>{ setTop(); freeze(1200); });
  const fi = document.getElementById('fileInput');
  if (fi) fi.addEventListener('change', ()=>{ setTop(); freeze(1500); });
})();
</script>


<script>
(function(){
  // Auto-scroll toggle (default OFF to preserve current safe behavior)
  window.__autoScrollEnabled = true;
  const autoEl = document.getElementById('autoScroll');
  if (autoEl) autoEl.checked = true;

  // Guard native scrolling functions when auto-scroll is OFF
  const orig = {
    siv: Element.prototype.scrollIntoView,
    st:  window.scrollTo,
    sb:  window.scrollBy
  };
  function applyGuards(){
    const on = !!window.__autoScrollEnabled;
    Element.prototype.scrollIntoView = on ? orig.siv : function(){};
    window.scrollTo = on ? orig.st : function(){};
    window.scrollBy = on ? orig.sb : function(){};
  }
  applyGuards();
  if (autoEl) autoEl.addEventListener('change', (e)=>{
    window.__autoScrollEnabled = !!e.target.checked;
    applyGuards();
  });

  // Visual toggles for Count-In & Metronome based on volumes
  function refreshTopToggles(){
    try{
      const c = document.getElementById('countIn');
      const m = document.getElementById('metronome');
      if (c && window.at) c.classList.toggle('active', (at.countInVolume||0) > 0);
      if (m && window.at) m.classList.toggle('active', (at.metronomeVolume||0) > 0);
    }catch(_){}
  }

  // Patch existing handlers to also refresh visuals
  const ci = document.getElementById('countIn');
  if (ci){
    const origCI = ci.onclick;
    ci.onclick = ()=>{ if (origCI) origCI(); refreshTopToggles(); };
  }
  const mt = document.getElementById('metronome');
  if (mt){
    const origMT = mt.onclick;
    mt.onclick = ()=>{ if (origMT) origMT(); refreshTopToggles(); };
  }

  // Track Solo/Mute highlighting with a small state map
  window.__trackToggleState = window.__trackToggleState || {};
  const oldRender = window.renderTrackList;
  window.renderTrackList = function(score){
    if (!window.__trackToggleState) window.__trackToggleState = {};
    const state = window.__trackToggleState;
    // Call the original
    oldRender(score);
    // Re-apply states & wire buttons
    const rows = Array.from(document.querySelectorAll('#tracks .track'));
    rows.forEach((row, idx)=>{
      const soloBtn = row.querySelector('.solo');
      const muteBtn = row.querySelector('.mute');
      // Restore visual state if known
      const st = state[idx] || {};
      if (soloBtn) soloBtn.classList.toggle('active', !!st.solo);
      if (muteBtn) muteBtn.classList.toggle('active', !!st.mute);
      // Wrap handlers to also toggle classes + remember
      if (soloBtn){
        const origSolo = soloBtn.onclick;
        soloBtn.onclick = ()=>{
          if (origSolo) origSolo();
          const on = !soloBtn.classList.contains('active');
          soloBtn.classList.toggle('active', on);
          state[idx] = state[idx] || {}; state[idx].solo = on;
        };
      }
      if (muteBtn){
        const origMute = muteBtn.onclick;
        muteBtn.onclick = ()=>{
          if (origMute) origMute();
          const on = !muteBtn.classList.contains('active');
          muteBtn.classList.toggle('active', on);
          state[idx] = state[idx] || {}; state[idx].mute = on;
        };
      }
    });
    // Also refresh top toggles
    refreshTopToggles();
  };

  // First refresh when AlphaTab initializes/loads
  setTimeout(refreshTopToggles, 300);
  setTimeout(refreshTopToggles, 1000);
})();
</script>


<script>
(function(){
  // Ensure our state map exists
  window.__trackToggleState = window.__trackToggleState || {};

  // Wrap/replace renderTrackList again to enforce correct toggle behavior
  const prevRender = window.renderTrackList;
  window.renderTrackList = function(score){
    if (typeof prevRender === 'function') prevRender(score);

    const state = window.__trackToggleState;
    const rows = Array.from(document.querySelectorAll('#tracks .track'));
    rows.forEach((row, idx)=>{
      const soloBtn = row.querySelector('.solo');
      const muteBtn = row.querySelector('.mute');

      // Restore visual state if previously set
      const st = state[idx] || {};
      if (soloBtn) soloBtn.classList.toggle('active', !!st.solo);
      if (muteBtn) muteBtn.classList.toggle('active', !!st.mute);

      // Replace handlers so they actually set API state instead of always 'true'
      if (soloBtn){
        soloBtn.onclick = ()=>{
          const on = !soloBtn.classList.contains('active');
          try { at.changeTrackSolo([at.score.tracks[idx]], on); } catch(_){}
          soloBtn.classList.toggle('active', on);
          state[idx] = state[idx] || {}; state[idx].solo = on;
        };
      }
      if (muteBtn){
        muteBtn.onclick = ()=>{
          const on = !muteBtn.classList.contains('active');
          try { at.changeTrackMute([at.score.tracks[idx]], on); } catch(_){}
          muteBtn.classList.toggle('active', on);
          state[idx] = state[idx] || {}; state[idx].mute = on;
        };
      }
    });
  };

  // If a score is already loaded, re-render list to apply overrides
  try {
    if (at && at.score && typeof window.renderTrackList === 'function'){
      window.renderTrackList(at.score);
    }
  } catch(_){}
})();
</script>


<script>
(function(){
  function setHeaderActive(which){
    const ids = ['play','pause','stop'];
    ids.forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      el.classList.toggle('active', id === which);
    });
  }

  function refreshTopControls(){
    try{
      const ci = document.getElementById('countIn');
      const mt = document.getElementById('metronome');
      if (ci && window.at) ci.classList.toggle('active', (at.countInVolume||0) > 0);
      if (mt && window.at) mt.classList.toggle('active', (at.metronomeVolume||0) > 0);
    }catch(_){}
  }

  // Wrap Count-In & Metronome to also update button classes
  const ci = document.getElementById('countIn');
  if (ci){
    const orig = ci.onclick;
    ci.onclick = ()=>{ if (orig) orig(); refreshTopControls(); };
  }
  const mt = document.getElementById('metronome');
  if (mt){
    const orig2 = mt.onclick;
    mt.onclick = ()=>{ if (orig2) orig2(); refreshTopControls(); };
  }

  // Play/Pause/Stop visuals based on clicks and player state
  const p  = document.getElementById('play');
  const pa = document.getElementById('pause');
  const st = document.getElementById('stop');
  if (p){
    const op = p.onclick;
    p.onclick = ()=>{ if (op) op(); setHeaderActive('play'); };
  }
  if (pa){
    const opa = pa.onclick;
    pa.onclick = ()=>{ if (opa) opa(); setHeaderActive('pause'); };
  }
  if (st){
    const ost = st.onclick;
    st.onclick = ()=>{ if (ost) ost(); setHeaderActive('stop'); };
  }

  function hookAT(){
    try{
      if (!window.at || !at.player) return;
      // Sync on state changes (1=playing,2=paused,3=stopped)
      at.player.stateChanged?.on?.((s)=>{
        if (s === 1) setHeaderActive('play');
        else if (s === 2) setHeaderActive('pause');
        else setHeaderActive('stop');
        refreshTopControls();
      });
      // Update volumes → button states after score load as well
      at.scoreLoaded?.on?.(()=>{ refreshTopControls(); });
    }catch(_){}
  }
  hookAT();
  setTimeout(hookAT, 500);
  setTimeout(()=>{ refreshTopControls(); }, 300);
  setTimeout(()=>{ refreshTopControls(); }, 1200);
})();
</script>




<script>
(function(){
  const se = document.scrollingElement || document.documentElement || document.body;
  let lastY = 0, lastX = 0;
  function clamp(){
    // Keep the page pinned; we scroll inside #alphaTab instead
    if (!window.__autoScrollEnabled){
      if (se.scrollTop !== 0) se.scrollTop = 0;
      if (se.scrollLeft !== 0) se.scrollLeft = 0;
    }
    requestAnimationFrame(clamp);
  }
  window.addEventListener('load', ()=>{ lastY=0; lastX=0; requestAnimationFrame(clamp); });
})();
</script>





<script>
(function(){
  // Auto-follow inside the sheet viewport so the playhead stays high enough
  // to reveal what's coming next (lookahead).
  const VP_ID = 'alphaTab';
  const LOOKAHEAD_RATIO = 0.12;   // keep cursor ~22% from the top
  const STICKY_TOP = 76;          // padding already applied to avoid header overlap
  const SMOOTH = 0.25;            // easing factor (0..1) for scroll changes
  const DEAD_BAND = 6;            // px tolerance to avoid jitter

  function vp(){ return document.getElementById(VP_ID); }
  function cursor(){
    return document.querySelector('#'+VP_ID+' .at-cursor-beat') ||
           document.querySelector('#'+VP_ID+' .at-cursor-bar');
  }

  function step(){
    const view = vp();
    if (!view){ requestAnimationFrame(step); return; }
    if (window.__autoScrollEnabled){
      const cur = cursor();
      if (cur){
        const vr = view.getBoundingClientRect();
        const cr = cur.getBoundingClientRect();
        // Position target a bit below the very top, leaving most of the viewport for the "next" row.
        const targetY = STICKY_TOP + (vr.height - STICKY_TOP) * LOOKAHEAD_RATIO;
        const curYIn = cr.top - vr.top; // cursor Y within viewport
        let delta = curYIn - targetY;   // positive = cursor too low -> scroll up (increase scrollTop)

        if (Math.abs(delta) > DEAD_BAND){
          // ease the scroll change for smooth following
          view.scrollTop += delta * SMOOTH;
        }
      }
    }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
})();
</script>


<script>
(function(){
  window.__trackToggleState = window.__trackToggleState || {};
  const prevRender = window.renderTrackList;
  window.renderTrackList = function(score){
    if (typeof prevRender === 'function') prevRender(score);
    // Tag rows with their track index for reliable lookup
    const rows = Array.from(document.querySelectorAll('#tracks .track'));
    rows.forEach((row, i)=> row.setAttribute('data-track-index', String(i)) );
  };

  // Build a Map from track object to index for quick lookup
  try{
    at.scoreLoaded?.on?.((score)=>{
      const m = new Map();
      (score.tracks||[]).forEach((t, i)=> m.set(t, i));
      window.__trackIndexMap = m;
      // Also ensure rows are tagged (if list already rendered)
      const rows = Array.from(document.querySelectorAll('#tracks .track'));
      rows.forEach((row, i)=> row.setAttribute('data-track-index', String(i)) );
    });
  }catch(_){}
})();
</script>



<script>
(function(){
  // CSS class is already defined; here we wire MIDI to rows
  const FLASH_MS = 280;
  let timers = {};
  function clearAll(){
    document.querySelectorAll('#tracks .track.playing').forEach(r=> r.classList.remove('playing'));
    for (const k in timers){ clearTimeout(timers[k]); delete timers[k]; }
  }
  function rows(){ return Array.from(document.querySelectorAll('#tracks .track')); }
  function tagRows(){
    const r = rows(); r.forEach((row,i)=> row.setAttribute('data-track-index', String(i)));
  }
  function rowByIndex(i){ return document.querySelector('#tracks .track[data-track-index="'+i+'"]') || rows()[i] || null; }

  // Build (and keep updating) a channel->track index map
  window.__trackIndexMap = window.__trackIndexMap || new Map();
  window.__channelToTrack = window.__channelToTrack || new Map();
  function numericChannelsFromTrack(t){
    const out = new Set();
    try {
      const pb = t && (t.playbackInfo || t.playback || t.midiPlayback || t._playbackInfo);
      if (pb){
        // Collect any numeric properties in [0..15]
        Object.keys(pb).forEach(k=>{
          const v = pb[k];
          if (typeof v === 'number' && v >= 0 && v <= 15) out.add(v|0);
          if (Array.isArray(v)) v.forEach(x=> { if (typeof x === 'number' && x>=0 && x<=15) out.add(x|0); });
        });
      }
      if (t && t.isPercussion) out.add(9); // MIDI ch-10 for drums as a heuristic
    } catch(_){}
    return Array.from(out);
  }
  function rebuildMaps(score){
    const m = new Map();
    const ch = new Map();
    const tracks = (score && score.tracks) ? score.tracks : [];
    tracks.forEach((t,i)=>{
      m.set(t, i);
      const chans = numericChannelsFromTrack(t);
      chans.forEach(c => { if (!ch.has(c)) ch.set(c, new Set()); ch.get(c).add(i); });
    });
    window.__trackIndexMap = m;
    window.__channelToTrack = ch;
    tagRows();
  }

  // Initialize maps once score loads
  try {
    at.scoreLoaded?.on?.((score)=> rebuildMaps(score));
  } catch(_){}
  // Also tag rows after (re)render of the list
  const prevRT = window.renderTrackList;
  window.renderTrackList = function(score){
    if (typeof prevRT === 'function') prevRT(score);
    tagRows();
    if (at && at.score) rebuildMaps(at.score);
  };

  function highlightIndex(idx){
    const r = rowByIndex(idx);
    if (!r) return;
    r.classList.add('playing');
    if (timers[idx]) clearTimeout(timers[idx]);
    timers[idx] = setTimeout(()=>{
      const rr = rowByIndex(idx);
      if (rr) rr.classList.remove('playing');
      delete timers[idx];
    }, FLASH_MS);
  }

  function idxFromElement(el){
    // Try map by actual track object
    try {
      const t = el?.beat?.voice?.track || el?.voice?.track || el?.staff?.track || el?.track || null;
      if (t && window.__trackIndexMap && window.__trackIndexMap.has(t)) return window.__trackIndexMap.get(t);
    } catch(_){}
    return null;
  }

  // Ensure we listen to NoteOn only
  try {
    at.midiEventsPlayedFilter = [alphaTab.midi.MidiEventType.NoteOn];
  } catch(_){ /* ignore */ }

  at.midiEventsPlayed.on(ev => {
    const seen = new Set();
    (ev?.events || []).forEach(me => {
      // 1) Element→Track (if available)
      let idx = idxFromElement(me?.element);
      if (idx != null) {
        if (!seen.has(idx)) { seen.add(idx); highlightIndex(idx); }
        return;
      }
      // 2) Channel→Track fallback
      let ch = null;
      try {
        ch = (typeof me.channel === 'number') ? me.channel : (typeof me.midiChannel === 'number' ? me.midiChannel : null);
        if (ch == null && me && typeof me.getChannel === 'function') ch = me.getChannel();
      } catch(_){}
      if (ch == null) return;
      const map = window.__channelToTrack;
      if (!map) return;
      const set = map.get(ch);
      if (!set || !set.size) return;
      set.forEach(ii => { if (!seen.has(ii)) { seen.add(ii); highlightIndex(ii); } });
    });
  });

  // Cleanup on pause/stop
  try { at.player.stateChanged?.on?.(s => { if (s !== 1) clearAll(); }); } catch(_){}
})();
</script>


<script>
(function(){
  function hideBrand(root){
    try {
      const scope = root || document;
      const nodes = scope.querySelectorAll('#alphaTab text, #alphaTab .at-brand, #alphaTab [class*="at-brand"]');
      nodes.forEach(n => {
        const txt = (n.textContent || '').trim();
        if (/rendered by alphaTab/i.test(txt)) {
          n.style.display = 'none';
          n.style.visibility = 'hidden';
          n.style.opacity = '0';
          // If it's a grouping element, remove to avoid stray spacing
          try { if (n.tagName && n.tagName.toLowerCase() !== 'text') n.remove(); } catch(e){}
        }
      });
    } catch(e){}
  }
  // Initial run
  hideBrand(document);
  // After a score is loaded/rerendered
  try { if (window.at && at.scoreLoaded && at.scoreLoaded.on) {
    at.scoreLoaded.on(() => setTimeout(() => hideBrand(document.getElementById('alphaTab')), 0));
  }} catch(e){}
  // MutationObserver to catch dynamic renderings
  try {
    const target = document.getElementById('alphaTab');
    if (target) {
      const mo = new MutationObserver(() => hideBrand(target));
      mo.observe(target, {childList: true, subtree: true});
    }
  } catch(e){}
})();
</script>

</body>
</html>

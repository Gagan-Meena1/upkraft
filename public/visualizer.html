<!DOCTYPE html>
<html data-theme="dark" lang="en">

<head>
  <script>window.textInputActive = false;</script>
  <meta charset="utf-8" />
  <!-- <meta content="width=device-width, initial-scale=1" name="viewport" /> -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>AlphaTab Guitar Practice Player (Top Controls, Note Highlight, MIDI to TAB)</title>
<script>
  (function(){
    try{
      var params = new URLSearchParams(location.search);
      var api = params.get('apiBase');
      if (api) {
        window.API_BASE_URL = api;
      }
      var songUrl = params.get('songUrl');
      if (songUrl) {
        window.__UPKRAFT_SELECTED_SONG__ = songUrl;
      }
    }catch(e){}
  })();
  // Optional: parent app may also set window.UPKRAFT_API_BASE
</script>

  <script src="https://cdn.jsdelivr.net/npm/@coderline/alphatab@1.6.1/dist/alphaTab.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi@2.0.28/build/Midi.js"></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js"></script>
  <script>
    if (window.pdfjsLib && pdfjsLib.GlobalWorkerOptions) {
      pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    }
  </script>

  <!-- pdfAnnotate Library for PDF annotations -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pdf-annotate@0.5.0/dist/pdf-annotate.css">
  <script src="https://cdn.jsdelivr.net/npm/pdf-annotate@0.5.0/dist/pdf-annotate.standalone.js"></script>

  <!-- <link rel="stylesheet" href="style.css"> -->

  <!--anurag script-->

<!-- <script>
(function(){
  // ye html ka tag hai mera
  var SCRAMBLE_HTML = '<!doctype html><html><head><meta charset="utf-8"><title>Not Allowed</title></head><body style="font-family:sans-serif;display:flex;align-items:center;justify-content:center;height:100vh;background:#111;color:#fff;"><div style="text-align:center;"><h1>Access Denied</h1><p>Viewing source or developer tools detected.</p></div></body></html>';
  var FLASH_MSG = 'Action blocked';

  // ye var hai mere
  function obliteratePage(){
    try {
      // ye main replace kar raha hu yadi koi other use kare to
      document.open();
      document.write(SCRAMBLE_HTML);
      document.close();
    } catch (e) {
      // ye massage hai yadi koi code nikalna chae to black overlay ke sath
      try {
        document.body && (document.body.innerHTML = '');
        var ov = document.createElement('div');
        ov.style.position = 'fixed';
        ov.style.left = '0';
        ov.style.top = '0';
        ov.style.width = '100%';
        ov.style.height = '100%';
        ov.style.background = '#000';
        ov.style.zIndex = '2147483647';
        ov.style.display = 'flex';
        ov.style.alignItems = 'center';
        ov.style.justifyContent = 'center';
        ov.style.color = '#fff';
        ov.style.fontFamily = 'sans-serif';
        ov.innerHTML = '<div style="text-align:center;"><h1>Access Denied</h1><p>Developer tools / view-source detected.</p></div>';
        document.documentElement.appendChild(ov);
      } catch(e2){}
    }
  }

  // ye massage hai jo ki show hoga yadi koi CTRL+U ya inspector se nikalna chae to
  function flash(msg){
    try {
      var id = '__flash_block_msg__';
      var el = document.getElementById(id);
      if(!el){
        el = document.createElement('div');
        el.id = id;
        el.style.position = 'fixed';
        el.style.top = '10px';
        el.style.left = '50%';
        el.style.transform = 'translateX(-50%)';
        el.style.zIndex = '2147483646';
        el.style.background = 'rgba(0,0,0,0.7)';
        el.style.color = '#fff';
        el.style.padding = '6px 10px';
        el.style.borderRadius = '6px';
        el.style.fontFamily = 'sans-serif';
        el.style.fontSize = '13px';
        document.body.appendChild(el);
      }
      el.textContent = msg || '';
      el.style.opacity = '1';
      clearTimeout(el.__t);
      el.__t = setTimeout(function(){ try{ el.style.transition='opacity 0.6s'; el.style.opacity='0'; }catch(e){} }, 900);
    } catch(e){}
  }

  // ye mere dwaya common shortcuts
  document.addEventListener('keydown', function(e){
    // Normalize key
    var key = e.key || e.keyCode;
    var ctrl = e.ctrlKey || e.metaKey; // cmd on mac
    var shift = e.shiftKey;
    // ye wo tag hai jinse code nikala jata hai maine diya hai or bhi kuch add kar sakte hain: F12, Ctrl+Shift+I/J, Ctrl+U, Ctrl+S, Ctrl+Shift+C
    if (key === 'F12' || key === 'F12' /* kuch browsers */ ||
        (ctrl && shift && (key === 'I' || key === 'i' || key === 'J' || key === 'j')) ||
        (ctrl && (key === 'U' || key === 'u')) ||
        (ctrl && (key === 'S' || key === 's')) ||
        (ctrl && shift && (key === 'C' || key === 'c'))
       ){
      e.preventDefault();
      e.stopPropagation && e.stopPropagation();
      flash(FLASH_MSG);
      // Slight delay then obliterate
      setTimeout(obliteratePage, 120);
      return false;
    }
  }, true);

  //  right-click ya kuch exta activety ke liye
  document.addEventListener('contextmenu', function(e){
    e.preventDefault();
    flash(FLASH_MSG);
    setTimeout(obliteratePage, 180);
    return false;
  });

  //  devtools se yadi koi nikalna chahe to ye rokega
  var devtoolsOpen = false;
  (function checkDevtools(){
    var before = new Date();
    debugger; 
    var after = new Date();
    if (after - before > 100) {
      if(!devtoolsOpen){
        devtoolsOpen = true;
      
        obliteratePage();
      }
    }
    // ye repeat periodically (but not too often) ke liye
    setTimeout(checkDevtools, 2000);
  })();

})();
</script> -->


  <script>
    var ENCODED = "REPLACE_WITH_YOUR_BASE64_BLOB";

    function decodeAndInject(b64){
      try {
        function b64_to_utf8(str) {
          return decodeURIComponent(Array.prototype.map.call(atob(str), function(c) {
            return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
          }).join(''));
        }
        var html = b64_to_utf8(b64);
        document.getElementById('app').innerHTML = html;
      } catch (err){
        document.getElementById('app').textContent = 'Failed to decode content';
      }
    }

    (function(){
      function obliterate(){
        try{
          document.open(); document.write('<body style="background:#111;color:#fff;display:flex;align-items:center;justify-content:center;height:100vh;"><div style="text-align:center;"><h1>Access Denied</h1><p>Viewing source or developer tools detected.</p></div></body>');
          document.close();
        } catch(e){
          try{
            document.body && (document.body.innerHTML='');
          } catch(e){}
        }
      }
      document.addEventListener('keydown', function(e){
        var key = e.key || e.keyCode;
        var ctrl = e.ctrlKey || e.metaKey, shift = e.shiftKey;
        if (key === 'F12' || (ctrl && (key==='u' || key==='U' || key==='s' || key==='S')) || (ctrl && shift && (key==='I' || key==='i' || key==='J' || key==='j'))){
          e.preventDefault(); e.stopPropagation && e.stopPropagation();
          setTimeout(obliterate, 80);
          return false;
        }
      }, true);
      document.addEventListener('contextmenu', function(e){ e.preventDefault(); setTimeout(obliterate, 160); });
    })();

    setTimeout(function(){ if (ENCODED && ENCODED.length>10) decodeAndInject(ENCODED); else document.getElementById('app').textContent = 'No content configured.'; }, 120);
  </script>


<style>
  
    :root{--bg:#0b1220;--fg:#e7f0ff;--muted:#a6b7d1;--panel:#101a2a;--panel2:#0e1830;--border:#1d2946;--accent:#4aa3ff;--accent2:#7bd88f;}
    :root{--header-h:64px}
    html,body{height:100%} body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
    header{background:#0f1a2f;border-bottom:1px solid var(--border);display:flex;align-items:center;padding:10px 14px;gap:6px;flex-wrap:wrap;position:sticky;top:0;z-index:5}
    header h2 {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 280px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0;
  border-right: 1px solid var(--border);
  background: var(--panel2);
  padding: 0 12px;
  box-sizing: border-box;
}
    .btn{padding:8px 12px;border-radius:10px;border:1px solid var(--border);background:#172544;color:var(--fg);cursor:pointer}
    .btn[disabled]{opacity:.6;cursor:not-allowed}
    .chip{padding: 4px 8px;border-radius: 4px;background:#0f203b;border:1px solid var(--border);color:var(--muted)}
    select,input[type="file"]{padding:8px;border-radius:10px;border:1px solid var(--border);background:#0f1a2f;color:var(--fg)}
    .wrap{display:grid;grid-template-columns:280px 1fr;gap:0;min-height:calc(100% - var(--header-h))}
    .sidebar{background:var(--panel2);border-right:1px solid var(--border);overflow:auto}
    .sidebar h3{margin:10px 12px;color:var(--muted);font-size:14px}
    .main{/* display:flex; *//* flex-direction:column; */}
    #alphaTab{flex:1;min-height:420px;background:white;border-bottom:1px solid var(--border);overflow:auto;position: relative;}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .slider{appearance:none;height:6px;background:#14264a;border-radius:8px}
    .slider::-webkit-slider-thumb{appearance:none;width:16px;height:16px;border-radius:50%;background:var(--accent)}
    .slider::-moz-range-thumb{width:16px;height:16px;border-radius:50%;background:var(--accent);border:none;cursor:pointer}
    .track{display:flex;gap:10px;align-items:center;padding:8px;border-bottom:1px dashed #15264a}
    .track .name{font-size:13px;line-height:1.2} .track .name small{display:block;color:#8ea1c5}
    .log{max-height:160px;overflow:auto;background:#0b1428;border-top:1px solid var(--border);padding:6px 8px;font-family:ui-monospace,Consolas,Menlo,monospace;color:#9db2d8}
    a.link{color:#9ecbff}
    .at-cursor-bar{background:rgba(255,242,0,.22)}
    .at-cursor-beat{background:rgba(64,255,160,.95);width:5px}
    .at-highlight *{fill:#00a2ff;stroke:#00a2ff}
    .at-selection *{fill:#ffd166;stroke:#ffd166}
  
header{flex-wrap:wrap;gap:8px;row-gap:6px;overflow-x:visible;overflow-y:visible;width:100%}
header .btn{font-size:12px;padding: 4px 8px;border-radius: 4px;}
header .chip{font-size: 10px;padding:4px 8px}
header select, header input[type="file"]{font-size:12px;padding:6px 8px}
header .link{font-size:11px}

  
/* Sidebar (left panel) compaction */
.sidebar{font-size:12px}
.sidebar h3{font-size:13px;margin:4px 0 8px}
.sidebar .btn{font-size:12px;padding:6px 10px;border-radius:8px}
.sidebar select,.sidebar input,.sidebar .chip,.sidebar label,.sidebar .link{font-size:12px}
  
/* Hide the MIDI to MusicXML converter section in the left panel */
.hide-left-section{display:none !important}

  
/* Keep content clear of the sticky header if any element tries to scroll into view */
html, body { scroll-padding-top: 72px; }
.at-content {scroll-padding-top: 72px;}

  
/* Provide headroom so autoscroll can't tuck staves under the sticky header */
#alphaTab.at-content { padding-top: 76px; }
#alphaTab.at-content * { scroll-margin-top: 76px; }

  
/* Active button highlight */
.btn.active{background:var(--accent);color:#08101f;box-shadow:0 0 0 2px var(--accent) inset, 0 0 8px rgba(74,163,255,.35)}
.sidebar .btn.active{background:var(--accent2);color:#08101f;box-shadow:0 0 0 2px var(--accent2) inset, 0 0 8px rgba(123,216,143,.35)}

  
/* Make top-panel Count-In & Metronome match Instruments' active color */
header #countIn.btn.active,
header #metronome.btn.active {
  background: var(--accent2);
  color: #08101f;
  box-shadow: 0 0 0 2px var(--accent2) inset, 0 0 8px rgba(123,216,143,.35);
}

  
/* Use the same active highlight in the header as in the sidebar */
header .btn.active{background:var(--accent2);color:#08101f;box-shadow:0 0 0 2px var(--accent2) inset,0 0 8px rgba(123,216,143,.35)}

  
/* Keep header visible; give the app its own scroll areas */
html, body { height: 100%; overflow: hidden; }
.wrap {height: calc(100vh - var(--header-h));}
.sidebar { height: 100%; overflow: auto; }
#alphaTab.at-content {height: 100%;overflow: auto;padding-top: 0;}
#alphaTab.at-content * {scroll-margin-top: 20px;}

  
/* Ensure the grid and main fill the viewport, and alphaTab scrolls */
.wrap {height: calc(100vh - var(--header-h)) !important;}
.main {height: 100% !important;overflow: hidden;/* width: calc(100% - 280px); */}
#alphaTab.at-content { height: 100% !important; overflow: auto !important; touch-action: pan-y; overscroll-behavior: contain; }

  
/* Highlight instruments currently sounding */
/* Subtle, thinner "now playing" style */
#tracks .track.playing {
  background: rgba(123,216,143,0.12) !important;
  box-shadow: 0 0 0 1px var(--accent2) inset, 0 0 6px rgba(123,216,143,.25) !important;
  border-radius: 12px;
  transition: background .15s ease, box-shadow .15s ease;
}

.key-dropdown {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  z-index: 1000;
  min-width: 120px;
  max-height: 200px;
  overflow-y: auto;
}

.key-dropdown.show {
  display: block;
}

.key-option {
  padding: 8px 12px;
  cursor: pointer;
  border-bottom: 1px solid var(--border);
  font-size: 12px;
}

.key-option:last-child {
  border-bottom: none;
}

.key-option:hover {
  background: var(--accent2);
  color: #08101f;
}

.key-option.current {
  background: var(--accent);
  color: #08101f;
}
/* Metronome Settings Dropdown */
.control-group {
  position: relative;
}

.metronome-settings {
  display: none;
  position: absolute;
  top: calc(100% + 4px);
  left: 50%;
  transform: translateX(-50%);  /* Add this to center it */
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 8px;
  z-index: 999999;
  min-width: 200px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.metronome-settings.show {
  display: block;
}

.metronome-settings.show ~ * .kbd-help,
body:has(.metronome-settings.show) .kbd-help {
  pointer-events: none !important;
  z-index: 1 !important;
}

.metronome-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
  font-size: 11px;
}

.metronome-row:last-child {
  margin-bottom: 0;
}

.metronome-row label {
  width: 60px;
  color: var(--muted);
  font-size: 10px;
}

.slider.mini {
  height: 4px;
  flex: 1;
  appearance: none;
  background: var(--border);
  border-radius: 2px;
  outline: none;
}

.slider.mini::-webkit-slider-thumb {
  appearance: none;
  width: 12px;
  height: 12px;
  background: var(--accent2);
  border-radius: 50%;
  cursor: pointer;
}

#metronomeVolumeLabel {
  width: 35px;
  text-align: right;
  color: var(--fg);
  font-size: 10px;
}

#metronomeSubdivision {
  flex: 1;
  padding: 3px 6px;
  font-size: 10px;
  background: var(--panel2);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 4px;
}
#metronomeSound {
  flex: 1;
  padding: 3px 6px;
  font-size: 10px;
  background: var(--panel2);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 4px;
}
/* Overlay root to host floating dropdowns above everything */
#ui-overlay-root{
  position: fixed;
  inset: 0;
  z-index: 2147483647;
  pointer-events: none;
}
#ui-overlay-root .dropdown-layer{
  position: absolute;
  pointer-events: auto;
  z-index: 2147483647;
}
/* Keep key dropdown on top and scrollable */
.key-dropdown{
  z-index: 1000;
  max-height: 260px;
  overflow-y: auto;
}

.row-break{flex-basis:100%;height:0}
header .row-second{/* margin-top:4px; */}

/* Keyboard shortcuts help */
.kbd-help {
  position: fixed;
  top: 93px;
  right: 15px;
  background: var(--panel);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 6px 10px;
  font-size: 11px;
  color: var(--muted);
  opacity: 0.5;
  transition: opacity 0.2s;
  z-index: 40;
  pointer-events: auto;
}
.kbd-help:hover {
  opacity: 1;
}
.kbd-help kbd {
  background: var(--panel2);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 2px 4px;
  margin: 0 2px;
  font-family: ui-monospace, monospace;
  font-size: 10px;
}

/* === On-screen Piano Keyboard (RH/LH + Labels) === */
:root {
  --piano-bg: #0b1428;
  --piano-border: var(--border, #23314f);
  --white-key: #f6f7fb;
  --white-key-border: #cfd8ea;
  --white-key-bottom: #aeb9cf;
  --white-key-pressed: #e7ecf7;
  --black-key-top: #1a1e2b;
  --black-key-bottom: #080c18;
  --black-key-border: #161b2a;
  --black-key-bottom-border: #0c1120;
  --rh-color: #60a5fa;
  --lh-color: #f59e0b;
}
.piano {
  position: relative;
  width: 100%;
  height: 190px;
  background: var(--piano-bg);
  border-top: 1px solid var(--piano-border);
  display: flex;
  align-items: flex-end;
  padding: 10px 12px;
  box-sizing: border-box;
  user-select: none;
  overflow: hidden;
}
.piano.hidden { display: none; }
.piano.labels-hidden .label { display: none; }

.piano .keys { position: relative; height: 100%; width: 100%; }
.piano .white-keys { display: flex; height: 100%; gap: 1px; }

.piano .white-key {
  flex: 1 1 auto;
  background: var(--white-key);
  border: 1px solid var(--white-key-border);
  border-bottom: 3px solid var(--white-key-bottom);
  border-radius: 0 0 6px 6px;
  position: relative;
  box-shadow: inset 0 -2px 0 rgba(0,0,0,0.08);
  transition: transform 0.02s, background 0.08s, box-shadow 0.08s;
}
.piano .white-key.pressed,
.piano .white-key.pressed-right,
.piano .white-key.pressed-left { transform: translateY(1px); }

.piano .white-key.pressed { background: var(--white-key-pressed); }
.piano .white-key.pressed-right {
  background: linear-gradient(#f8fbff, #e9f3ff);
  box-shadow: inset 0 -2px 0 rgba(96,165,250,0.6), 0 0 0 2px rgba(96,165,250,0.9), 0 0 16px rgba(96,165,250,0.75), 0 0 32px rgba(96,165,250,0.35);
}
.piano .white-key.pressed-left {
  background: linear-gradient(#fffaf4, #fff1da);
  box-shadow: inset 0 -2px 0 rgba(245,158,11,0.65), 0 0 0 2px rgba(245,158,11,0.95), 0 0 16px rgba(245,158,11,0.8), 0 0 32px rgba(245,158,11,0.45);
}

.piano .black-keys {
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 62%;
  display: grid;
  grid-auto-flow: column;
  grid-auto-columns: 1fr;
  pointer-events: none;
}
.piano .black-key-wrap { position: relative; }

.piano .black-key {
  position: absolute;
  left: 50%; transform: translateX(-50%);
  width: 66%; height: 100%;
  background: linear-gradient(var(--black-key-top), var(--black-key-bottom));
  border: 1px solid var(--black-key-border);
  border-bottom: 3px solid var(--black-key-bottom-border);
  border-radius: 0 0 6px 6px;
  box-shadow: 0 2px 5px rgba(0,0,0,0.25), inset 0 -2px 0 rgba(255,255,255,0.04);
  pointer-events: auto;
  transition: transform 0.02s, filter 0.08s, box-shadow 0.08s;
}
.piano .black-key.pressed,
.piano .black-key.pressed-right,
.piano .black-key.pressed-left {
  transform: translateX(-50%) translateY(1px);
}
.piano .black-key.pressed { filter: brightness(1.2); }
.piano .black-key.pressed-right {
  box-shadow: 0 2px 5px rgba(0,0,0,0.35), 0 0 0 2px rgba(96,165,250,0.95) inset, 0 0 14px rgba(96,165,250,0.85), 0 0 28px rgba(96,165,250,0.5);
  filter: brightness(1.15);
}
.piano .black-key.pressed-left {
  box-shadow: 0 2px 5px rgba(0,0,0,0.35), 0 0 0 2px rgba(245,158,11,0.95) inset, 0 0 14px rgba(245,158,11,0.9), 0 0 28px rgba(245,158,11,0.6);
  filter: brightness(1.15);
}

/* Note labels */
.piano .label {
  position: absolute;
  bottom: 6px; left: 6px;
  font-size: 10px;
  color: #516280;
  pointer-events: none;
}
.piano .white-key .label { bottom: 6px; left: 6px; }
.piano .black-key .label {
  top: 6px; left: 50%; transform: translateX(-50%);
  color: #eaf1ff;
  font-size: 9px;
  text-shadow: 0 1px 0 rgba(0,0,0,0.6);
}

@media (max-width: 900px) { .piano { height: 150px; } }

.piano .white-key.pressed-right,
.piano .white-key.pressed-left,
.piano .black-key.pressed-right,
.piano .black-key.pressed-left { z-index: 2; }

/* --- AlphaTab courtesy credit (stable, accessible) --- */
.main { position: relative; }
.at-credit {
  position: absolute; right: 8px; bottom: 6px;
  font-size: clamp(10px, 0.8vw, 12px); line-height: 1;
  color: #6b7280; opacity: .85; z-index: 3;
}
.at-credit a {
  text-decoration: none; border-bottom: 1px dotted currentColor;
  padding: 6px 8px; margin: -6px -8px;
  outline-offset: 2px;
}
.at-credit a:focus-visible { outline: 2px solid currentColor; }
@media (prefers-color-scheme: dark) { .at-credit { color: #9ca3af; } }
@media print { .at-credit { display: none; } }

/* Right-align the second row without affecting the first row */
header { display: flex; flex-wrap: wrap; align-items: center; }
header .row-break { flex-basis: 100%; height: 0; }

/* Keep second row on a single line; allow horizontal scroll if crowded */
header .row.row-second::-webkit-scrollbar { height: 6px; }
header .row.row-second::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

/* Stack Speed and A/B vertically without affecting row flow */
header .speed-box {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

/* Second-row layout with left/right groups */
header .row.row-second {
  display:flex;
  width: 100%;
  justify-content: space-between;
  align-items: center;
  gap: 8px;
  flex-wrap: nowrap;
  min-width: 0;
  /* padding-right: 12px; */
}
header .row-second-left,
header .row-second-right {
  display:flex;
  align-items:center;
  gap: 8px;
  min-width: 0;
}
header .row-second-left {/* margin-left: var(--left-cluster-offset, 0px); */}
header .row-second-right { margin-right: 8px; flex-wrap: nowrap; }
header .row-second-right > * { flex: 0 0 auto; }
header .row-second-rec { position:absolute; left: var(--record-offset, 0px); top: 0; z-index: 4; }
header .row-second-rec .rec { padding: 8px 12px; font-weight: 600; letter-spacing: .2px; }
header .row-second-rec .rec.rec-on { background: #8b1d2f; color: #fff; box-shadow: 0 0 0 2px rgba(255,80,80,.4) inset; }
header .row.row-second {position: relative;/* min-height: 40px; */padding-top: 8px;}

#bpmBtn {
  min-width: 80px;
  font-weight: 600;
  background: var(--panel2);
}

#bpmBtn.active {
  background: var(--accent);
  color: white;
}

#bpmSettings {
  min-width: 220px;
}

#meta {
  min-width: 150px;
  max-width: 150px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  display: inline-block;
  box-sizing: border-box;
}

/* --- Upkraft Practice Studio: Record round icon + REC lamp --- */
.btn.rec {
  width: 26px;
  height: 26px;
  padding: 0;
  border-radius: 9999px;
  position: relative;
  text-indent: -9999px;
  overflow: hidden;
  display: inline-grid;
  place-items: center;
}
.btn.rec::after {
  content: ""; position: absolute; width: 10px; height: 10px;
  border-radius: 9999px; background: #ff3b30;
  box-shadow: 0 0 0 0 rgba(255,59,48,0.65);
  transform: translate(-50%,-50%); left: 50%; top: 50%;
  }
.btn.rec.rec-on::after {
  animation: rec-pulse 1s ease-in-out infinite;
}
@keyframes rec-pulse {
  0%   { box-shadow: 0 0 0 0 rgba(255,59,48,0.7); }
  70%  { box-shadow: 0 0 0 10px rgba(255,59,48,0.0); }
  100% { box-shadow: 0 0 0 0 rgba(255,59,48,0.0); }
}
.rec-indicator {
  display: inline-flex; align-items: center; gap: 6px;
  padding: 4px 10px; border-radius: 9999px;
  background: rgba(255,59,48,0.12);
  border: 1px solid rgba(255,59,48,0.35);
  color: #ff6b6b; font-weight: 700; letter-spacing: .3px;
}
.rec-indicator .dot {
  width: 8px; height: 8px; border-radius: 999px; background: #ff3b30;
  box-shadow: 0 0 0 0 rgba(255,59,48,0.6);
  animation: rec-pulse 1.5s ease-out infinite;
}

.chip.equal-h { display:inline-flex; align-items:center; }

label.chip.equal-h.btn-like {
  background: var(--button-bg);
  color: var(--fg);
  border: 1px solid var(--border);
  border-radius: 4px;
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 4px 8px;
  font-weight: 500;
  /* height: auto; */
  font-size: 12px;
}
label.chip input[type="checkbox"],
label.chip.equal-h.btn-like input[type="checkbox"] {
  transform: scale(1.05);
  accent-color: var(--accent2);
  vertical-align: middle;
  margin: 0 6px 0 0;
  position: relative;
  top: 0;
}

label.chip.equal-h.btn-like {
  /* box-sizing: border-box; */
  /* vertical-align: middle; */
}
header .btn { 
  vertical-align: middle; 
}

.row-first-controls {
  /* display: flex; */
  /* flex-wrap: wrap; */
  /* gap: 8px; */
  /* align-items: center; */
  /* margin-left: var(--first-row-offset, 0px); */
  /* min-width: 0; */
}

#barA, #barB {
  width: 48px;
  text-align: center;
}

.top-panel, .controls, .panel-row {
  display: flex;
  flex-wrap: nowrap;
  align-items: center;
  gap: 6px;
  flex-direction: row;
}

header .row-second-right {
  flex-wrap: nowrap;
  overflow-x: auto;
  min-width: 0;
}

.piano {height: 300px;}
.piano .white-key {min-height: 100%;}
.piano .black-keys {height: 70%;}
.piano .label {font-size:10px;}
.piano .black-key .label {font-size:9px;}
@media (max-width:900px){.piano{height:220px;}}


html, body { background: var(--bg); color: var(--fg); }

/* Control groups visibility in light theme */
html[data-theme="light"] .control-group {
  background: rgba(122, 76, 255, 0.05) !important;  /* Light purple tint */
  border: 1px solid var(--border) !important;
  padding: 4px 4px !important;
  border-radius: 8px !important;
}

/* Ensure control groups stay visible even on smaller screens */
html[data-theme="light"] .control-group.transport-group,
html[data-theme="light"] .control-group:has(.btn),
html[data-theme="light"] .control-group:has(#record) {
  background: rgba(122, 76, 255, 0.05) !important;
  border: 1px solid var(--border) !important;
  padding: 4px 4px !important;
}

/* Dark theme (default) */
:root, html[data-theme="dark"] {
  --bg: #0b1220;
  --fg: #e7f0ff;
  --muted: #a6b7d1;
  --panel: #101a2a;
  --panel2: #0e1830;
  --border: #1d2946;
  --accent: #4aa3ff;
  --accent2: #7bd88f;
  --header-bg: #0f1a2f;
  --sheet-bg: #ffffff;
  --button-bg: #172544;
  --chip-bg: #0f203b;
}

/* Light theme (snapshot style) */
html[data-theme="light"] {
  --bg: #f9f7fd;
  --fg: #1e1033;
  --muted: #5a4b82;
  --panel: #e8e0ff;
  --panel2: #e0d6ff;
  --border: #7a4cff;
  --accent: #5a2ecc;
  --accent2: #4a24b5;
  --header-bg: #f4efff;
  --sheet-bg: #ffffff;
  --button-bg: #ffffff;
  --chip-bg: #ffffff;
}

header { background: var(--header-bg); border-bottom:1px solid var(--border); }
.btn { background: var(--button-bg); color: var(--fg); border:1px solid var(--border); }
.btn.active { background: var(--accent2); color:#fff; }

html[data-theme="light"] header { background: var(--header-bg) !important; border-bottom:1px solid var(--border) !important; }
html[data-theme="light"] .btn { background: var(--button-bg) !important; color: var(--fg) !important; border-color: var(--border) !important; }
html[data-theme="light"] header .btn { background: var(--button-bg) !important; color: var(--fg) !important; border-color: var(--border) !important; }
html[data-theme="light"] .btn.active, 
html[data-theme="light"] header .btn.active { background: var(--accent2) !important; color: #ffffff !important; }

html[data-theme="light"] .chip,
html[data-theme="light"] header .chip { background: var(--chip-bg) !important; color: var(--fg) !important; border-color: var(--border) !important; }

html[data-theme="light"] select,
html[data-theme="light"] header select,
html[data-theme="light"] input[type="file"],
html[data-theme="light"] header input[type="file"] { background: var(--chip-bg) !important; color: var(--fg) !important; border-color: var(--border) !important; }

html[data-theme="light"] .key-dropdown { background: var(--panel) !important; border-color: var(--border) !important; }
html[data-theme="light"] .key-option.current { background: var(--accent) !important; color: #fff !important; }
html[data-theme="light"] .key-option:hover { background: var(--accent2) !important; color: #fff !important; }

html[data-theme="light"] #countIn.btn,
html[data-theme="light"] #metronome.btn { background: var(--button-bg) !important; }

html[data-theme="light"] .kbd-help { background: var(--panel) !important; border-color: var(--border) !important; color: var(--muted) !important; }
html[data-theme="light"] .kbd-help kbd { background: var(--panel2) !important; border-color: var(--border) !important; }

html[data-theme="light"] .btn,
html[data-theme="light"] .chip,
html[data-theme="light"] select,
html[data-theme="light"] input[type="file"] {
  border-color: var(--border) !important;
}
html[data-theme="light"] .btn.active {
  background: var(--accent2) !important;
  color: #fff !important;
}
html[data-theme="light"] a.link { color: var(--accent) !important; }

html[data-theme="light"] header #countIn.btn.active,
html[data-theme="light"] header #metronome.btn.active,
html[data-theme="light"] header .btn.active { 
  background: var(--accent2) !important;
  color: #ffffff !important;
  text-shadow: none !important;
}
html[data-theme="light"] header #countIn.btn,
html[data-theme="light"] header #metronome.btn { 
  color: var(--fg) !important;
}
/* Compact theme toggle button with icons */
#toggleTheme {
  min-width: auto;
  padding: 3px 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
}

#toggleTheme .theme-icon {
  display: flex;
  transition: transform 0.3s ease;
  font-size: 12px;
  justify-content: center;
  align-items: center;
}

#toggleTheme:hover .theme-icon {
  transform: rotate(20deg);
}

/* Icon changes based on theme 
html[data-theme="light"] #toggleTheme .theme-icon::before {
  content: "☀️";
}

html[data-theme="dark"] #toggleTheme .theme-icon::before {
  content: "🌙";
}*/



header { padding: 8px 12px !important; }
header .row.row-second {/* min-height: 32px !important; */}
header .row-second-rec .rec {
  font-size: 8px !important;
  padding: 3px 8px !important;
  line-height: 1.1 !important;
  border-radius: 999px !important;
}

header .row-second-rec .rec::before {
  content: "";
  display: inline-block;
  width: 6px; height: 6px;
  margin-right: 6px;
  border-radius: 50%;
  background: #dc2626;
  box-shadow: 0 0 0 0 rgba(220,38,38,0.6);
  vertical-align: middle;
  transform: translateY(-1px);
}
header .row-second-rec .rec.rec-on {
  background: #b91c1c !important;
  color: #ffffff !important;
  border-color: #7f1d1d !important;
  box-shadow: 0 0 0 2px rgba(255,80,80,.35) inset, 0 0 10px rgba(255,80,80,.35) !important;
  animation: recPulse 1.2s ease-in-out infinite;
}
header .row-second-rec .rec.rec-on::before {
  background: #ff3b30;
  animation: recDot 1s ease-in-out infinite;
}

@keyframes recPulse {
  0%, 100% { box-shadow: 0 0 0 2px rgba(255,80,80,.35) inset, 0 0 10px rgba(255,80,80,.35); }
  50%      { box-shadow: 0 0 0 2px rgba(255,80,80,.55) inset, 0 0 18px rgba(255,80,80,.55); }
}
@keyframes recDot {
  0%, 100% { box-shadow: 0 0 0 0 rgba(255,59,48,0.55); opacity: 1; }
  50%      { box-shadow: 0 0 0 6px rgba(255,59,48,0.15); opacity: .85; }
}
#record{ font-weight: 400 !important; }

/* Recording Countdown Styles */
.countdown-overlay {
  position: fixed;
  inset: 0;
  z-index: 10000;
  background: rgba(0, 0, 0, 0.85);
  display: flex;
  align-items: center;
  justify-content: center;
  backdrop-filter: blur(4px);
}

.countdown-content {
  text-align: center;
  animation: fadeIn 0.3s ease-out;
}

.countdown-number {
  font-size: 120px;
  font-weight: bold;
  color: var(--accent2);
  text-shadow: 0 0 40px rgba(123, 216, 143, 0.5);
  animation: pulse 1s ease-in-out infinite;
  line-height: 1;
  margin-bottom: 20px;
}

.countdown-number.recording {
  color: #ff3b30;
  text-shadow: 0 0 40px rgba(255, 59, 48, 0.7);
  font-size: 60px;
}

.countdown-text {
  font-size: 24px;
  color: var(--fg);
  margin-bottom: 30px;
  opacity: 0.9;
}

.countdown-cancel {
  background: var(--panel2);
  padding: 10px 24px;
  opacity: 0.7;
  transition: opacity 0.2s;
}

.countdown-cancel:hover {
  opacity: 1;
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

@keyframes fadeIn {
  from { opacity: 0; transform: scale(0.9); }
  to { opacity: 1; transform: scale(1); }
}



header {
  min-height: 64px;
  padding: 0 !important;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  position: sticky;
  top: 0;
  z-index: 10;
}

.row-first-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
  /* margin-left: var(--first-row-offset, 0px); */
  /* padding: 10px 16px 0 16px; */
  /* min-width: 0; */
}

.row.row-second {
  /* padding: 0 16px 10px 16px; */
  /* min-height: 36px; */
}

.control-group {
  display: flex;
  gap: 6px;
  align-items: center;
  padding: 4px 4px;
  border-radius: 8px;
  background: rgba(255,255,255,0.02);
  border: 1px solid rgba(255,255,255,0.05);
}

header .btn {
  /* font-weight: 500; */
  /* letter-spacing: 0.01em; */
}

.transport-group .btn {
  font-weight: 600;
}

.key-selector {
  display: flex;
  gap: 8px;
  align-items: center;
  margin-left: 8px;
}

.control-group:hover {
  background: rgba(255,255,255,0.04);
  border-color: rgba(255,255,255,0.1);
}

header .btn:focus-visible {
  outline: 2px solid var(--accent2);
  outline-offset: 2px;
}

@media (max-width: 1300px) {
  .control-group {
    /* Keep the borders but make them more subtle on small screens */
    padding: 2px 4px;
    padding: 0;
  }
}

.logo-staff {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 15px;
  font-weight: 600;
  padding: 10px;
  justify-content: center;
}

.logo-staff .staff-container {
  position: relative;
  width: 45px;
  height: 32px;
  flex-shrink: 0;
}

.logo-staff .staff-lines {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 100%;
  height: 20px;
}

.logo-staff .staff-line {
  position: absolute;
  width: 100%;
  height: 1px;
  background: var(--muted);
  opacity: 0.6;
}

.logo-staff .staff-line:nth-child(1) { top: 0; }
.logo-staff .staff-line:nth-child(2) { top: 25%; }
.logo-staff .staff-line:nth-child(3) { top: 50%; }
.logo-staff .staff-line:nth-child(4) { top: 75%; }
.logo-staff .staff-line:nth-child(5) { top: 100%; }

.logo-staff .notes {
  position: absolute;
  width: 100%;
  height: 100%;
}

.logo-staff .note {
  position: absolute;
  width: 6px;
  height: 8px;
  background: var(--accent2);
  border-radius: 50%;
  opacity: 0;
  animation: noteFloat 2.5s infinite;
  transform-origin: center;
}

.logo-staff .note::before {
  content: '';
  position: absolute;
  right: -1px;
  top: -8px;
  width: 1px;
  height: 10px;
  background: var(--accent2);
}

.logo-staff .note:nth-child(1) { 
  left: 8px; 
  bottom: 8px; 
  animation-delay: 0s; 
}
.logo-staff .note:nth-child(2) { 
  left: 16px; 
  bottom: 12px; 
  animation-delay: 0.4s; 
}
.logo-staff .note:nth-child(3) { 
  left: 24px; 
  bottom: 16px; 
  animation-delay: 0.8s; 
}
.logo-staff .note:nth-child(4) { 
  left: 32px; 
  bottom: 20px; 
  animation-delay: 1.2s; 
}

@keyframes noteFloat {
  0%, 20% { 
    opacity: 0; 
    transform: scale(0.5) translateY(4px); 
  }
  40%, 70% { 
    opacity: 1; 
    transform: scale(1) translateY(0); 
  }
  90%, 100% { 
    opacity: 0; 
    transform: scale(0.5) translateY(-2px); 
  }
}

.logo-staff .staff-text {
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  font-weight: 700;
  line-height: 1.2;
}

html[data-theme="light"] .logo-staff .staff-text {
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

html[data-theme="light"] .logo-staff .note,
html[data-theme="light"] .logo-staff .note::before {
  background: var(--accent2);
}

.logo-staff {
  transition: transform 90ms ease, filter 90ms ease;
}
.logo-staff.beat-kick {
  transform: scale(1.03);
  filter: brightness(1.08);
}


.sidebar {
  background: var(--panel2);
  border-right: 1px solid var(--border);
  overflow: auto;
  font-size: 12px;
  padding: 0;
  /* width: 280px; */
}

.sidebar h3 {
  padding: 11px 16px;
  background: var(--panel);
  border-bottom: 1px solid var(--border);
  font-weight: 700;
  font-size: 14px;
  text-align: center;
  width: 100%;
  color: var(--accent);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin: 0;
  width: 100%;
  padding-left: 0;
  padding-right: 0;
}

.track {
  display: grid;
  grid-template-columns: auto 1fr auto;
  align-items: center;
  padding: 16px;
  border-bottom: 1px dashed rgba(255,255,255,0.1);
  gap: 12px;
  transition: all 0.2s ease;
  position: relative;
}

.track:nth-child(odd) { background: rgba(255,255,255,0.01); }
.track:nth-child(even) { background: rgba(0,0,0,0.02); }

.track:hover .instrument-icon {
  transform: rotate(5deg) scale(1.1);
  transition: transform 0.2s ease;
}
.track:hover {
  background: rgba(255,255,255,0.03);
  padding-left: 20px;
}

.track.playing {
  background: linear-gradient(90deg, transparent, rgba(123,216,143,0.08), transparent);
  border-left: 2px solid var(--accent2);
}

.track .instrument-icon {
  width: 28px;
  height: 28px;
  border-radius: 6px;
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: bold;
  flex-shrink: 0;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.track .track-info {
  min-width: 0;
}

.track .track-info .track-name,
.track .name {
  font-weight: 600;
  font-size: 13px;
  color: var(--fg);
  margin-bottom: 3px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  display: block;
}

.track .track-info .track-type,
.track .name small {
  font-size: 11px;
  color: var(--muted);
  font-style: italic;
  font-weight: 400;
}

.track .track-controls {
  display: flex;
  gap: 8px;
  align-items: center;
}

.track .render {
  width: 16px;
  height: 16px;
  accent-color: var(--accent2);
}

.track .control-group {
  display: flex;
  border: 1px solid var(--border);
  border-radius: 6px;
  overflow: hidden;
}

.track .btn {
  padding: 6px 8px;
  font-size: 10px;
  border: none;
  background: transparent;
  color: var(--muted);
  cursor: pointer;
  transition: all 0.2s;
  border-right: 1px solid var(--border);
  min-width: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.track .btn:last-child {
  border-right: none;
}

.track .btn:hover {
  background: var(--accent);
  color: white;
}

.track .btn.active {
  background: var(--accent2);
  color: white;
}

html[data-theme="light"] .track .instrument-icon {
  background: linear-gradient(135deg, var(--accent), var(--accent2));
  color: white;
}

html[data-theme="light"] .track.playing {
  background: linear-gradient(90deg, transparent, rgba(74,36,181,0.08), transparent);
  border-left: 2px solid var(--accent2);
}

.track .instrument-icon.guitar {
  background: linear-gradient(135deg, #ff6b6b, #ee5a24);
}

.track .instrument-icon.piano {
  background: linear-gradient(135deg, #4834d4, #686de0);
}

.track .instrument-icon.drums {
  background: linear-gradient(135deg, #ff9ff3, #f368e0);
}

.track .instrument-icon.bass {
  background: linear-gradient(135deg, #26de81, #20bf6b);
}

.track .instrument-icon.vocals {
  background: linear-gradient(135deg, #fed330, #f7b731);
}


.loop-marker{position:absolute;top:0;bottom:0;width:3px;z-index:15;pointer-events:none}
.loop-start{background:linear-gradient(to bottom,#4aa3ff,#4aa3ff88)!important;border-left:2px solid #4aa3ff}
.loop-end{background:linear-gradient(to bottom,#7bd88f,#7bd88f88)!important;border-right:2px solid #7bd88f}
.loop-label{position:absolute;top:-25px;background:#000;color:#fff;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:600;white-space:nowrap;box-shadow:0 2px 8px rgba(0,0,0,.3);animation:labelFadeIn .3s ease-out}
@keyframes labelFadeIn{from{opacity:0;transform:translateY(-5px)}to{opacity:1;transform:translateY(0)}}
.loop-controls{display:flex;flex-direction:row;gap:8px;align-items:center;flex-wrap:nowrap}
.loop-inputs{display:flex;gap:8px;align-items:center;flex-wrap:nowrap}
.loop-inputs input[type=number]{font-size:12px;text-align:center;width:60px;background: transparent;border: none;color:var(--fg,#eee);padding: 0;margin: 0;line-height: 14px;font-weight: 400;}
.loop-inputs input[type=number]:focus{border-color:var(--accent,#4aa3ff);outline:none;box-shadow:0 0 0 2px rgba(74,163,255,.2)}
.loop-start{display:none !important;border:0 !important;background:transparent !important}
.loop-active {
  position: relative;
}
.loop-active::before {
  content: "LOOP";
  position: absolute;
  top: 10px;
  right: 10px;
  background: var(--accent);
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 10px;
  font-weight: bold;
  z-index: 10;
  animation: blink 1s infinite;
}
@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}


.song-modal { position: fixed; inset: 0; z-index: 9999; }
.song-modal-backdrop { position:absolute; inset:0; background: rgba(0,0,0,0.45); }
.song-modal-dialog {
  position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
  width: min(720px, 92vw); max-height: 80vh; overflow: hidden;
  background: var(--panel); border: 1px solid var(--border); border-radius: 12px; box-shadow: 0 12px 40px rgba(0,0,0,0.35);
  display: grid; grid-template-rows: auto 1fr auto;
}
.song-modal-header { display:flex; align-items:center; justify-content:space-between; padding: 12px 14px; border-bottom: 1px solid var(--border); background: var(--panel2); }
.song-modal-body { padding: 12px 14px; display: grid; gap: 10px; }
.song-modal-footer { padding: 10px 14px; border-top:1px solid var(--border); display:flex; justify-content:flex-end; }
.song-modal-close { line-height:1; }
#songSearchInput {
  width: 100%; padding: 10px 12px; border-radius: 10px; border:1px solid var(--border);
  background: var(--button-bg); color: var(--fg); font-size: 14px;
}
.song-results { display:grid; gap: 8px; overflow:auto; max-height: 52vh; padding-right: 2px; }
.song-result { border:1px solid var(--border); border-radius: 10px; padding: 10px 12px; background: var(--panel2); cursor: pointer; }
.song-result:hover, .song-result[aria-selected="true"] { outline: 2px solid var(--accent2); }
.song-result .title { font-weight: 700; }
.song-result .meta { color: var(--muted); font-size: 12px; margin-top: 2px; }
.song-hint { color: var(--muted); font-size: 12px; }

#alphaTab { position: relative; }
#alphaTab.pdf-mode { background: var(--sheet-bg, #ffffff); padding-top: 50px;}
#alphaTab.pdf-mode > :not(.pdf-overlay) { visibility: hidden; }
#alphaTab .pdf-overlay {
  position: absolute; inset: 0;
  overflow: visible;
  background: var(--sheet-bg, #ffffff);
}
#alphaTab .pdf-toolbar {
  position: fixed;
  top: 88px;
  left: 280px;
  right: 0;
  z-index: 999;
  display: flex;
  gap: 8px;
  align-items: center;
  padding: 6px 12px;
  background: var(--panel2);
  border-bottom: 1px solid var(--border);
  border-top: 1px solid var(--border);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}
#alphaTab .pdf-toolbar .btn {
  padding: 4px 8px;
  border-radius: 8px;
  background: var(--button-bg, #172544);
  color: var(--fg, #e7f0ff);
  border: 1px solid var(--border, #1d2946);
  cursor: pointer;
  font-size: 12px;
}
#alphaTab .pdf-toolbar .meta {
  margin-left: auto; font-size: 12px; color: var(--muted, #a6b7d1);
}
#alphaTab .pdf-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 12px;
  padding: 8px 12px 12px 12px;
}
#alphaTab .pdf-page { width: 100%; display: flex; justify-content: center; }
#alphaTab .pdf-page canvas {
  display: block; max-width: 100%; height: auto !important;
  box-shadow: 0 2px 12px rgba(0,0,0,0.12); border-radius: 6px;
}

.wrap.pdf-active { grid-template-columns: 280px 1fr !important; }

#alphaTab .pdf-toolbar .pdf-select {
  border-radius: 4px;
  background: var(--button-bg, #172544);
  color: var(--fg, #e7f0ff);
  border: 1px solid var(--border, #1d2946);
  padding: 4px 8px;
  font-size: 12px;
}

/* PDF Annotation Controls */
.pdf-annotation-controls {
  display: flex;
  gap: 6px;
  align-items: center;
  padding: 0 0px 0 8px;
  border-left: 1px solid var(--border);
  flex-wrap: wrap;
}

.pdf-tool-separator {
  width: 1px;
  height: 24px;
  background: var(--border);
  margin: 0 4px;
}

.pdf-separator {
  width: 1px;
  height: 24px;
  background: var(--border);
  margin: 0 2px;
}

.pdf-annotation-btn {
  padding: 4px 8px;
  border-radius: 4px;
  border: 1px solid var(--border);
  background: var(--button-bg, #172544);
  color: var(--fg);
  cursor: pointer;
  font-size: 12px;
  display: flex;
  align-items: center;
  gap: 4px;
  transition: background 0.2s;
  white-space: nowrap;
}

.pdf-annotation-btn:hover {
  background: #1a2d52;
}

.pdf-annotation-btn.active {
  background: var(--accent, #4aa3ff);
  color: #08101f;
  border-color: var(--accent);
  font-weight: 600;
}

.pdf-annotation-btn[disabled] {
  opacity: 0.5;
  cursor: not-allowed;
}

.pdf-save-btn {
  background: #0fa000;
  border-color: #1d8000;
}

.pdf-save-btn:hover {
  background: #11b800;
}

.pdf-color-picker {
  width: 28px;
  height: 28px;
  border: 2px solid var(--border);
  border-radius: 4px;
  cursor: pointer;
  padding: 1px;
  background: white;
  accent-color: #FFFF00;
}

.pdf-size-input {
  width: 35px;
  padding: 4px 6px;
  border: 1px solid var(--border);
  background: #0f1a2f;
  color: var(--fg);
  border-radius: 4px;
  font-size: 11px;
}

.pdf-size-display {
  font-size: 11px;
  color: var(--muted);
  min-width: 15px;
  display: none !important;
}

.pdf-control-label {
  font-size: 11px;
  color: var(--muted);
  white-space: nowrap;
}

/* Shapes Dropdown */
.pdf-shapes-dropdown-wrapper {
  position: relative;
  display: inline-block;
}

.pdf-shapes-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  background: var(--panel2);
  border: 1px solid var(--border);
  border-radius: 6px;
  min-width: 120px;
  z-index: 9999;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  display: flex;
  flex-direction: column;
  padding: 4px;
  gap: 2px;
}

.pdf-shapes-dropdown.show {
  display: flex;
}

.pdf-shape-item {
  padding: 6px 8px;
  font-size: 11px;
  background: transparent;
  border: none;
  color: #e7f0ff;
  border-radius: 4px;
  cursor: pointer;
  text-align: left;
  transition: background 0.2s;
}

.pdf-shape-item:hover {
  background: var(--accent);
  color: #08101f;
}

/* Text Tool Dropdown */
.pdf-text-dropdown-wrapper {
  position: relative;
  display: inline-block;
}

.pdf-text-dropdown {
  position: absolute;
  top: 100%;
  left: 0;
  background: var(--panel2);
  border: 1px solid var(--border);
  border-radius: 6px;
  min-width: 180px;
  z-index: 9999;
  padding: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.pdf-text-dropdown.show {
  display: flex;
}

.pdf-dropdown-group {
  display: flex;
  flex-direction: column;
  gap: 3px;
}

.pdf-dropdown-label {
  font-size: 10px;
  color: var(--muted);
}

.pdf-dropdown-select {
  padding: 4px 6px;
  font-size: 11px;
  background: #172544;
  border: 1px solid var(--border);
  color: #e7f0ff;
  border-radius: 4px;
}

.pdf-dropdown-number {
  padding: 4px 6px;
  font-size: 11px;
  background: #172544;
  border: 1px solid var(--border);
  color: #e7f0ff;
  border-radius: 4px;
  width: 100%;
}

.pdf-checkbox-label {
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 11px;
  color: var(--muted);
  cursor: pointer;
}

.pdf-checkbox-label input[type="checkbox"] {
  cursor: pointer;
}

/* PDF Annotation Layer */
.pdf-annotation-layer {
  transform-origin: top left;

  cursor: crosshair;
  z-index: 10;
}

/* Responsive Header Improvements */
@media (max-width: 1400px) {
  header h2 {
    width: 220px !important;
    font-size: 13px !important;
  }
  
  .logo-staff .staff-text {
    font-size: 13px !important;
  }
  
  .logo-staff .staff-container {
    width: 35px !important;
  }
}

@media (max-width: 1300px) {
  header h2 {
    width: 180px !important;
    font-size: 12px !important;
  }
  
  .row-first-controls {
    gap: 6px !important;
  }
  
  .control-group {
    gap: 4px !important;
    padding: 2px 4px !important;
  }
  
  header .btn {
    padding: 3px 6px !important;
    font-size: 9px !important;
    min-height: 20px;
    display: flex;
    align-items: center;
    white-space: nowrap;
  }
}

@media (max-width: 900px) {
  header h2 {
    display: none !important;
  }
  
  header {
    --first-row-offset: 0px !important;
  }
  
  .row-first-controls {
    /* margin-left: 0 !important; */
    /* padding: 8px 12px 0 12px !important; */
    /* width: 100%; */
    /* justify-content: center; */
  }
  
  .row.row-second {
    /* padding: 0 12px 8px 12px !important; */
    /* justify-content: center !important; */
    padding-top: 4px !important;
  }
  
  .row-second-left {
    /* margin-left: 0 !important; */
    /* flex: 1; */
    /* justify-content: center; */
  }
  
  .loop-controls {
    /* display: none !important; */
  }
  
  #meta {
    max-width: 150px !important;
  }
}

.row-first-controls {
  /* max-width: calc(100% - var(--first-row-offset, 0px) - 20px); */
  /* overflow-x: hidden; */
  /* scrollbar-width: thin; */
}

/* Only show scroll on very small screens */
@media (max-width: 600px) {
  .row-first-controls {
    /* overflow-x: auto; */
    /* scrollbar-width: thin; */
    flex-wrap: nowrap;
  }
}

/* Hide the scrollbar completely for medium screens */
.row-first-controls::-webkit-scrollbar {
  display: none;  /* Hide scrollbar for Chrome, Safari */
  height: 4px;
}

/* Ensure no horizontal overflow on header */
header {
  overflow-x: hidden !important;
  overflow-y: hidden !important;
}

.row.row-second {
  /* overflow-x: hidden !important; */
}

.row-first-controls::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 2px;
}

@media (max-width: 768px) {
  .key-selector {
    /* display: none !important; */
  }
  
  #toggleTheme {
    /* display: none !important; */
  }
  
  #toggleTreble {
    display: none !important;
  }
  
  #countIn {
    /* display: none !important; */
  }
}

header {
  min-height: auto !important;
  height: auto !important;
}

.row-first-controls,
.row.row-second {
}

.wrap {
  min-width: 320px !important;
  max-width: 100% !important;
}

#alphaTab {
  min-width: 0 !important;
  width: 100% !important;
}

/* Annotation System Styles */
.tool-btn {
  padding: 8px 12px;
  border: 1px solid var(--border);
  background: #172544;
  color: var(--fg);
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.2s ease;
}

.tool-btn:hover {
  background: #1a3a5c;
  border-color: #4aa3ff;
}

.tool-btn.active {
  background: #4aa3ff;
  color: #08101f;
  border-color: #4aa3ff;
}

#annotationCanvas.active {
  display: block !important;
  pointer-events: auto;
  z-index: 1000;
}

#annotationCanvas {
  pointer-events: none;
  z-index: 0;
}

#annotationPanel {
  z-index: 9999 !important;
  pointer-events: auto !important;
}

#annotationPanel * {
  pointer-events: auto !important;
}

#annotationPanel .tool-btn {
  padding: 6px 10px;
  font-size: 11px;
  background: #172544;
  border: 1px solid #1d2946;
  color: #e7f0ff;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s ease;
}

#annotationPanel .tool-btn:hover {
  background: #1a3a5c;
  border-color: #4aa3ff;
}

#annotationPanel .tool-btn.active {
  background: #4aa3ff !important;
  color: #08101f !important;
  border-color: #4aa3ff !important;
  font-weight: 600;
}

#annotationPanel input[type="range"] {
  pointer-events: auto !important;
  cursor: pointer;
}

#annotationPanel input[type="color"] {
  pointer-events: auto !important;
  cursor: pointer;
}

#annotationPanel .btn {
  pointer-events: auto !important;
  cursor: pointer;
}



/* Hide the keyboard help when annotating so it never steals clicks */
body.annotating .kbd-help {
  display: none !important;
  pointer-events: none !important;
  z-index: 1 !important;
  opacity: 0 !important;
}
/* Keep annotation panel above everything and clickable */
#annotationPanel {
  position: fixed !important;
  z-index: 2147483600 !important;
}
#annotationPanel, #annotationPanel * { pointer-events: auto !important; }


/***********new css for music player***********/

.music-header-box {
    display: flex;
    align-items: center;
}

.music-header-box .logo-music {
    width: 280px;
    height: 100%;
}

.music-header-box  .right-menu-music {
    width: calc(100% - 280px);
    border-left: 1px solid #1d2946;
    padding: 14px;
}

.top-music-header {
    display: flex;
    align-items: center;
}

.record-box label {
    font-size: 12px;
    font-weight: 400;
}

* {
    box-sizing: border-box;
}


@media only screen and (max-width: 1250px) {

    
    .music-header-box .logo-music {
    width: 220px;
}

body .wrap {
    min-width: 220px !important;
    grid-template-columns: 220px 1fr !important;
}

.btn.rec {
    width: 22px;
    height: 22px;
}

.record-box label {
    font-size: 9px;
}

header .chip {
    font-size: 9px;
    padding: 3px 6px;
    white-space: nowrap;
}

span#speedDisplay {
    font-size: 9px !important;
}

label.chip.equal-h.btn-like {
    padding: 3px 6px;
    font-size: 9px;
}

label.chip input[type="checkbox"], label.chip.equal-h.btn-like input[type="checkbox"] {
    transform: scale(1);
}

.music-header-box .right-menu-music {
    width: calc(100% - 220px);
}

#meta {
    min-width: 100px;
}

#bpmBtn {
    min-width: auto;
}

.kbd-help {
    top: 90px;
    font-size: 9px;
}


    body .wrap.pdf-active {
        min-width: 220px !important;
        grid-template-columns: 220px 1fr !important;
    }
    




/*****************/




#alphaTab .pdf-toolbar {
    left: 220px;
    top: 84px;
}

#alphaTab .pdf-toolbar .btn {
    font-size: 9px;
    padding: 3px 5px;
    white-space: nowrap;
}

#alphaTab .pdf-toolbar .pdf-select {
    font-size: 9px;
    padding: 3px 4px;
    max-width: 60px !important;
}

.pdf-annotation-btn {
    padding: 3px 5px;
    font-size: 9px;
}


.pdf-control-label {
    font-size: 9px;
}

.pdf-color-picker {
    width: 20px;
    height: 18px;
    padding: 0;
    margin: 0 2px;
    border: none;
    border-radius: 2px;
}

}


@media only screen and (max-width: 990px) {


  header {
    /* overflow-x: initial !important; */
}

.music-header-box {
    flex-direction: column;
    width: 100%;
}

.music-header-box .right-menu-music {
    width: 100%;
    padding: 8px 10px;
}

.logo.logo-staff {
    padding-bottom: 0;
}

.top-music-header {
    justify-content: center;
}

.kbd-help {
    top: 115px;
    right: 0;
}

header .row.row-second {
    justify-content: center;
  }

#alphaTab .pdf-toolbar {
    top: 110px;
    overflow: scroll;
}

header .btn {
        font-size: 8px !important;
      }

      .pdf-annotation-controls {
    white-space: nowrap;
    flex-wrap: nowrap;
}

}







@media only screen and (max-width: 767px) {

.top-music-header {
    /* flex-direction: column; */
    white-space: nowrap;
    justify-content: space-between;
}


.kbd-help {
  display: none !important;
    top: 112px;
    width: 100%;
    /* text-align: center; */
    /* display: flex; */
    /* flex-wrap: wrap; */
    /* justify-content: center; */
    /* gap: 4px; */
    white-space: nowrap;
    left: 118px;
    overflow: scroll;
}


.scroll-mobile-view {
    overflow: auto;
}

.track .track-info {
    display: none;
}

body .wrap, body .wrap.pdf-active {
    min-width: 100px;
    grid-template-columns: 110px 1fr !important;
}

.track {
    padding: 15px 8px;
    gap: 4px;
}

.sidebar h3 {
    font-size: 11px;
    padding: 5px;
}

.track .track-controls {
    gap: 3px;
}

.track .btn {
    padding: 3px !important;
    font-size: 8px;
    min-width: auto;
}

.control-group {
    gap: 0 !important;
}


#alphaTab .pdf-toolbar {
    white-space: nowrap;
    left: 110px;
    overflow: auto;
}

.pdf-annotation-controls {
    flex-wrap: nowrap;
}



}


</style>




</head>


<body>
  <header>
    <div class="music-header-box">
      <div class="logo-music">
        <div class="logo logo-staff">
          <div class="staff-container">
            <div class="staff-lines">
              <div class="staff-line"></div>
              <div class="staff-line"></div>
              <div class="staff-line"></div>
              <div class="staff-line"></div>
              <div class="staff-line"></div>
            </div>
            <div class="notes">
              <div class="note"></div>
              <div class="note"></div>
              <div class="note"></div>
              <div class="note"></div>
            </div>
          </div>
          <div class="staff-text">Upkraft Practice Studio</div>
        </div>
      </div>

      <div class="right-menu-music">
        <div class="scroll-mobile-view">
          <div class="scroll-mobile-view-auto">
            <div class="top-music-header">
              <div class="row-first-controls">
                <input accept=".gp,.gp3,.gp4,.gp5,.gp6,.gp7,.gp8,.gpx,.xml,.musicxml,.mxl,.cap,.capx,.mid,.midi,.pdf"
                  id="fileInput" type="file" style="display:none">
                <button class="btn" id="loadFileBtn">Load File</button>
                <button class="btn" id="searchSong">🔎 Song</button>

                <div style="display:flex; gap:6px; align-items:center;">
                  <button class="btn" id="play">▶ Play</button>
                  <button class="btn" id="pause">⏸ Pause</button>
                  <button class="btn" id="stop">⏹ Stop</button>
                </div>
                <div class="record-box">
                  <label for="">REC</label>
                  <button class="btn rec" id="record">Record</button>
                </div>

                <label class="chip"
                  style="white-space: nowrap; display: inline-flex; align-items: center; gap: 4px;">Speed
                  <input type="range" id="speed" min="0.25" max="2" step="0.05" value="1" class="slider"
                    style="width: 60px; height: 6px; margin: 0 4px;">
                  <span id="speedDisplay"
                    style="font-weight: bold; min-width: 35px; text-align: center; font-size: 12px;">100%</span>
                </label>

                <label class="chip equal-h btn-like" style=""><input checked="" id="autoScroll" type="checkbox" />
                  Scroll</label>

                <button class="btn" id="countIn">Count‑In</button>

                <button class="btn" id="metronome">Metronome</button>
                <div class="metronome-settings" id="metronomeSettings">
                  <div class="metronome-row">
                    <label>Volume</label>
                    <input type="range" id="metronomeVolume" min="0" max="100" value="70" class="slider mini">
                    <span id="metronomeVolumeLabel">70%</span>
                  </div>
                  <div class="metronome-row">
                    <label>Pattern</label>
                    <select id="metronomeSubdivision">
                      <option value="0.25">Whole notes</option>
                      <option value="0.5">Half notes</option>
                      <option value="1" selected>Quarter notes</option>
                      <option value="2">Eighth notes</option>
                      <option value="3">Triplets</option>
                      <option value="4">Sixteenths</option>
                    </select>
                  </div>
                  <div class="metronome-row">
                    <label>Sound</label>
                    <select id="metronomeSound">
                      <option value="click">Click</option>
                      <option value="beep">Beep</option>
                      <option value="tick">Tick</option>
                      <option value="woodblock">Woodblock</option>
                      <option value="cowbell">Cowbell</option>
                    </select>
                  </div>
                </div>
              </div>
              <!-- Annotation Panel (positioned fixed, moved to 2nd row button) -->
              <div id="annotationPanel"
                style="display:none; position:fixed; background: var(--panel); border:2px solid var(--accent); border-radius:8px; padding:8px 10px; z-index:10000; min-width:620px; box-shadow: 0 8px 24px rgba(0,0,0,0.5);">
                <div style="display:flex; gap:6px; flex-wrap:wrap; margin-bottom:8px; align-items:center;">
                  <!-- Pen Tool -->
                  <button class="tool-btn" id="penTool"
                    style="padding:4px 8px; font-size:10px; background: #172544; border: 1px solid #1d2946; color: #e7f0ff; border-radius:6px; cursor:pointer;">✏️
                    Pen</button>

                  <!-- Highlight Tool -->
                  <button class="tool-btn" id="highlightTool"
                    style="padding:4px 8px; font-size:10px; background: #172544; border: 1px solid #1d2946; color: #e7f0ff; border-radius:6px; cursor:pointer;">🖍️
                    Highlight</button>

                  <!-- Shapes Dropdown -->
                  <div style="position: relative; display: inline-block;">
                    <button class="tool-btn" id="shapesBtn"
                      style="padding:4px 8px; font-size:10px; background: #172544; border: 1px solid #1d2946; color: #e7f0ff; border-radius:6px; cursor:pointer;">🔷
                      Shapes ▼</button>
                    <div id="shapesDropdown"
                      style="display:none; position:absolute; top:100%; left:0; background:var(--panel2); border:1px solid var(--border); border-radius:6px; min-width:140px; z-index:9999; box-shadow:0 4px 12px rgba(0,0,0,0.3); padding: 4px; display: grid; grid-template-columns: repeat(4, 1fr); gap: 2px;">
                      <button class="tool-btn" id="arrowTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Arrow">➜</button>
                      <button class="tool-btn" id="circleTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Circle">⭕</button>
                      <button class="tool-btn" id="rectangleTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Rectangle">⬜</button>
                      <button class="tool-btn" id="lineTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Line">📏</button>
                      <button class="tool-btn" id="starTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Star">⭐</button>
                      <button class="tool-btn" id="quarterNoteTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Quarter Note">♩</button>
                      <button class="tool-btn" id="eighthNoteTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Eighth Note">♪</button>
                      <button class="tool-btn" id="beamedEighthTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Beamed Eighth Notes">♫</button>
                      <button class="tool-btn" id="beamedSixteenthTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Beamed Sixteenth Notes">♬</button>
                      <button class="tool-btn" id="flatTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Flat">♭</button>
                      <button class="tool-btn" id="naturalTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Natural">♮</button>
                      <button class="tool-btn" id="sharpTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Sharp">♯</button>
                      <button class="tool-btn" id="trebleClefTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Treble Clef">𝄞</button>
                      <button class="tool-btn" id="bassClefTool"
                        style="padding:4px; font-size:14px; background:transparent; border:none; color:#e7f0ff; border-radius:0; cursor:pointer; text-align:center;"
                        title="Bass Clef">𝄢</button>
                    </div>
                  </div>

                  <!-- Eraser Tool -->
                  <button class="tool-btn" id="fillTool"
                    style="padding:4px 8px; font-size:10px; background: #172544; border: 1px solid #1d2946; color: #e7f0ff; border-radius:6px; cursor:pointer;">🪣
                    Fill</button>

                  <!-- Eraser Tool -->
                  <button class="tool-btn" id="eraserTool"
                    style="padding:4px 8px; font-size:10px; background: #172544; border: 1px solid #1d2946; color: #e7f0ff; border-radius:6px; cursor:pointer;">🧹
                    Eraser</button>

                  <!-- Separator -->
                  <span style="width:1px; height:20px; background:#1d2946; margin:0 2px;"></span>

                  <!-- Color Picker -->
                  <label style="font-size:10px; color:var(--muted); white-space:nowrap;">Color:</label>
                  <input type="color" id="annotationColor" value="#ff0000"
                    style="width:24px; height:24px; border-radius:4px; cursor:pointer; border:1px solid #1d2946;">

                  <!-- Size Control -->
                  <label style="font-size:10px; color:var(--muted); white-space:nowrap;">Size:</label>
                  <input type="number" id="annotationSize" min="1" max="20" value="3"
                    style="width:35px; padding:3px 4px; font-size:10px; background: #172544; border: 1px solid #1d2946; color: #e7f0ff; border-radius:4px; cursor:pointer; text-align:center;">
                  <span id="sizeDisplay" style="font-size:10px; color:var(--muted); min-width:15px;">3</span>

                  <!-- Action Buttons -->
                  <button class="btn" id="undoAnnotation"
                    style="padding:4px 6px; font-size:10px; background: #172544; border: 1px solid #1d2946; color: #e7f0ff; border-radius:6px; cursor:pointer; white-space:nowrap;">↶
                    Undo</button>
                  <button class="btn" id="redoAnnotation"
                    style="padding:4px 6px; font-size:10px; background: #172544; border: 1px solid #1d2946; color: #e7f0ff; border-radius:6px; cursor:pointer; white-space:nowrap; opacity: 0.5;"
                    disabled>↷ Redo</button>
                  <button class="btn" id="clearAnnotations"
                    style="padding:4px 6px; font-size:10px; background: #172544; border: 1px solid #1d2946; color: #e7f0ff; border-radius:6px; cursor:pointer; white-space:nowrap;">🗑️
                    Clear</button>
                  <button class="btn" id="saveWithSheet"
                    style="padding:4px 6px; font-size:10px; background: #0fa000; border: 1px solid #1d8000; color: #e7f0ff; border-radius:6px; cursor:pointer; white-space:nowrap;">💾
                    Save</button>
                </div>
              </div>

              <script>
                // Shapes dropdown toggle
                document.getElementById('shapesBtn').addEventListener('click', function (e) {
                  e.stopPropagation();
                  const dropdown = document.getElementById('shapesDropdown');
                  dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
                });

                // Close dropdowns when clicking outside
                document.addEventListener('click', function () {
                  document.getElementById('shapesDropdown').style.display = 'none';
                });

                // Close dropdowns when clicking inside shapes dropdown
                document.getElementById('shapesDropdown').addEventListener('click', function (e) {
                  e.stopPropagation();
                  setTimeout(() => this.style.display = 'none', 100);
                });
              </script>
              <!-- Key Selector -->
              <div class="key-selector">
                <button class="btn" id="keyBtn">Key: C</button>
                <div class="key-dropdown" id="keyDropdown">
                  <div class="key-option" data-key="C">C Major</div>
                  <div class="key-option" data-key="G">G Major</div>
                  <div class="key-option" data-key="D">D Major</div>
                  <div class="key-option" data-key="A">A Major</div>
                  <div class="key-option" data-key="E">E Major</div>
                  <div class="key-option" data-key="B">B Major</div>
                  <div class="key-option" data-key="F#">F# Major</div>
                  <div class="key-option" data-key="C#">C# Major</div>
                  <div class="key-option" data-key="F">F Major</div>
                  <div class="key-option" data-key="Bb">Bb Major</div>
                  <div class="key-option" data-key="Eb">Eb Major</div>
                  <div class="key-option" data-key="Ab">Ab Major</div>
                  <div class="key-option" data-key="Db">Db Major</div>
                  <div class="key-option" data-key="Gb">Gb Major</div>
                  <div class="key-option" data-key="Am">A Minor</div>
                  <div class="key-option" data-key="Em">E Minor</div>
                  <div class="key-option" data-key="Bm">B Minor</div>
                  <div class="key-option" data-key="F#m">F# Minor</div>
                  <div class="key-option" data-key="C#m">C# Minor</div>
                  <div class="key-option" data-key="G#m">G# Minor</div>
                  <div class="key-option" data-key="D#m">D# Minor</div>
                  <div class="key-option" data-key="A#m">A# Minor</div>
                  <div class="key-option" data-key="Dm">D Minor</div>
                  <div class="key-option" data-key="Gm">G Minor</div>
                  <div class="key-option" data-key="Cm">C Minor</div>
                  <div class="key-option" data-key="Fm">F Minor</div>
                  <div class="key-option" data-key="Bbm">Bb Minor</div>
                  <div class="key-option" data-key="Ebm">Eb Minor</div>
                </div>
                <label class="chip equal-h btn-like" title="Transpose pitch up/down"><input id="transposeToggle"
                    type="checkbox" /> T⇅</label>
              </div>
            </div>


            <!-- <span class="row-break"></span> -->
            <div class="row row-second">
              <div class="row-second-rec"> </div>
              <div class="row-second-left">
                <div class="loop-controls">
                  <div class="loop-inputs">
                    <label class="chip">A: <input type="number" id="barA" min="1" placeholder="1" max="999"
                        step="1"></label>
                    <label class="chip">B: <input type="number" id="barB" min="1" placeholder="8" max="999"
                        step="1"></label>
                    <button class="btn" id="applyLoop">Apply Loop</button>
                    <button class="btn" id="clearAB">Clear Loop</button>
                  </div>
                </div>
                <span class="chip" id="time">00:00 /
                  00:00</span>
                <span class="chip" id="meta">No score
                  loaded</span>
                <button class="btn" id="bpmBtn" style="margin-left: 1px;">BPM: 120</button>
                <button class="btn" id="toggleKeyboard">Keyboard</button>
                <button class="btn" id="toggleTreble">Treble Clef</button>
                <button class="btn" id="toggleAnnotations" title="Toggle annotation mode">Annotate</button>
                <button class="btn" id="toggleTheme" title="Toggle theme">
                  <span class="theme-icon">🌙</span>
                </button>
              </div>
              <div class="row-second-right"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </header>
  <div class="wrap">
    <aside class="sidebar">
      <h3>Instruments</h3>
      <div id="tracks"></div>
      <div class="hide-left-section">
        <h3>MIDI to MusicXML (for TAB)</h3>
        <div style="padding:8px; display:grid; gap:8px">
          <label class="chip">Quantize
            <select id="quant">
              <option>4</option>
              <option selected="">8</option>
              <option>12</option>
              <option>16</option>
              <option>24</option>
              <option>32</option>
            </select>
          </label>
          <label class="chip">Time Sig
            <select id="tsNum">
              <option>2</option>
              <option>3</option>
              <option selected="">4</option>
              <option>6</option>
              <option>7</option>
              <option>9</option>
              <option>12</option>
            </select> /
            <select id="tsDen">
              <option>1</option>
              <option>2</option>
              <option selected="">4</option>
              <option>8</option>
              <option>16</option>
            </select>
          </label>
          <label><input id="merge" type="checkbox"> Merge all tracks</input></label>
          <label><input id="includePerc" type="checkbox"> Include percussion (Ch.10)</input></label>
        </div>
        <div class="log" id="log"></div>
      </div>
    </aside>
    <main class="main">
      <div class="at-content" id="alphaTab"></div>
      <div id="pianoContainer" class="piano hidden" aria-hidden="true"></div>
      <!-- Annotation Canvas -->
      <canvas id="annotationCanvas"
        style="position:absolute; top:0; left:0; display:none; z-index:100; cursor:crosshair;"></canvas>
      <div class="at-credit" role="contentinfo" aria-label="Powered by alphaTab">
        <a href="https://www.alphatab.net" target="_blank" rel="noopener noreferrer">Powered by alphaTab</a>
      </div>

    </main>
  </div>

  <!-- Keyboard shortcuts help -->
  <div class="kbd-help">
    <kbd>Space</kbd> Play/Pause <kbd>S</kbd> Stop <kbd>A</kbd> Scroll <kbd>C</kbd> Count-in <kbd>M</kbd> Metronome
    <kbd>L</kbd> Loop <kbd>↑↓</kbd> Speed <kbd>T</kbd> Transpose <kbd>R</kbd> Record
  </div>

  <!-- Song Search Modal -->
  <div id="songSearchModal" class="song-modal" aria-hidden="true" role="dialog" aria-labelledby="songSearchTitle"
    style="display:none;">
    <div class="song-modal-backdrop"></div>
    <div class="song-modal-dialog" role="document">
      <div class="song-modal-header">
        <h3 id="songSearchTitle">Search Song</h3>
        <button class="btn song-modal-close" id="songModalClose" aria-label="Close">✕</button>
      </div>
      <div class="song-modal-body">
        <input type="text" id="songSearchInput" placeholder="Search by title, artist, tags..."
          aria-label="Song search input" />
        <div id="songResults" class="song-results" role="listbox" aria-label="Search results"></div>
        <div class="song-hint">Tip: Press <kbd>Enter</kbd> to open the first result. Use ↑/↓ to navigate.</div>
      </div>
      <div class="song-modal-footer">
        <button class="btn" id="songModalCancel">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Recording Confirmation Modal -->
  <div id="recordConfirmModal" class="song-modal" aria-hidden="true" role="dialog" style="display:none;">
    <div class="song-modal-backdrop"></div>
    <div class="song-modal-dialog" role="document" style="width: min(480px, 90vw);">
      <div class="song-modal-header" style="position: relative;">
        <h3 style="margin: 0; text-align: center; width: 100%;">Recording Complete</h3>
        <button class="btn song-modal-close"
          style="position: absolute; right: 14px; top: 50%; transform: translateY(-50%);"
          onclick="document.getElementById('recordConfirmModal').style.display='none'; document.getElementById('recordConfirmModal').setAttribute('aria-hidden','true'); pendingBlob=null;"
          aria-label="Close">✕</button>
      </div>
      <div class="song-modal-body" style="text-align: center; padding: 24px;">
        <p style="margin-bottom: 20px; color: var(--fg);">Your practice session has been recorded. What would you like
          to do?</p>
        <div style="display: flex; gap: 12px; justify-content: center;">
          <button class="btn" id="recordAIBtn"
            style="background: var(--accent2); color: white; padding: 12px 24px; line-height: 1.4; min-width: 180px;">
            🤖 Save Recording<br>Get AI Feedback
          </button>
          <button class="btn" id="recordAgainBtn" style="padding: 12px 24px;">
            🎤 Record Again
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Instrument Selection Modal -->
  <div id="instrumentSelectModal" class="song-modal" aria-hidden="true" role="dialog" style="display:none;">
    <div class="song-modal-backdrop"></div>
    <div class="song-modal-dialog" role="document" style="width: min(420px, 90vw);">
      <div class="song-modal-header" style="position: relative;">
        <h3 style="margin: 0; text-align: center; width: 100%;">Select Your Instrument</h3>
        <button class="btn song-modal-close"
          style="position: absolute; right: 14px; top: 50%; transform: translateY(-50%);"
          onclick="document.getElementById('instrumentSelectModal').style.display='none'; document.getElementById('instrumentSelectModal').setAttribute('aria-hidden','true');"
          aria-label="Close">✕</button>
      </div>
      <div class="song-modal-body" style="text-align: center; padding: 24px;">
        <p style="margin-bottom: 20px; color: var(--fg);">Which instrument did you record with?</p>
        <div style="display: flex; justify-content: center; margin-bottom: 20px;">
          <select id="instrumentSelect"
            style="width: 220px; padding: 10px 12px; border-radius: 8px; background: var(--button-bg); color: var(--fg); border: 1px solid var(--border); font-size: 14px; text-align: center;">
            <option value="">-- Select Instrument --</option>
            <option value="guitar">🎸 Guitar</option>
            <option value="piano">🎹 Piano</option>
          </select>
        </div>
        <div style="display: flex; gap: 12px; justify-content: center;">
          <button class="btn" id="instrumentConfirmBtn"
            style="background: var(--accent2); color: white; padding: 12px 24px; min-width: 120px;">
            Confirm
          </button>
          <button class="btn" id="instrumentBackBtn" style="padding: 12px 24px;">
            Back
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Analysis Loader -->
<div id="analysisLoader" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; justify-content: center; align-items: center; flex-direction: column;">
  <div style="text-align: center;">
    <div style="width: 60px; height: 60px; border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
    <p style="color: white; font-size: 18px; margin: 0;">Analyzing your performance...</p>
    <p style="color: #ccc; font-size: 14px; margin-top: 10px;">This may take a moment</p>
  </div>
</div>

<style>
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
</style>
  <div aria-hidden="true" id="ui-overlay-root"></div>

  <script>
    // ====== CONSOLIDATED INITIALIZATION AND STATE MANAGEMENT ======
    // Single global selector
    const $ = s => document.querySelector(s);
    const $$ = s => Array.from(document.querySelectorAll(s));

    // Unified state manager
    const AppState = {
      isPlaying: false,
      isRecording: false,
      autoScrollEnabled: true,
      trackStates: {},
      currentKey: 'C',
      originalKey: 'C',
      currentTransposition: 0,
      preservedMetronomeVolume: 0,
      preservedCountInVolume: 0,
      aBar: null,
      bBar: null,
      aTick: null,
      bTick: null
    };

    const metronomeSettings = {
      volume: 0.7,
      subdivision: 1,
      enabled: false,
      soundType: 'click'
    };

    // Single log function
    const logEl = $('#log');
    function log(m) {
      console.log(m);
      if (logEl) {
        const d = document.createElement('div');
        d.textContent = m;
        logEl.appendChild(d);
      }
    }

    // ====== ALPHATAB INITIALIZATION ======
    const at = new alphaTab.AlphaTabApi($('#alphaTab'), {
      player: {
        enablePlayer: true,
        enableCursor: true,
        enableScrolling: false,
        soundFont: "https://cdn.jsdelivr.net/npm/@coderline/alphatab@1.6.1/dist/soundfont/sonivox.sf2",
        scrollMode: "continuous"  // Add this if needed
      },
      display: {
        staveProfile: alphaTab.StaveProfile.ScoreTab,
        layoutMode: alphaTab.LayoutMode.Page
      },
      notation: {
        displayTranspositionPitches: []
      }
    });
    window.at = at;

    // ====== KEY SIGNATURE SYSTEM ======
    const keySignatures = {
      'C': { sharps: 0, flats: 0, semitones: 0 },
      'G': { sharps: 1, flats: 0, semitones: 7 },
      'D': { sharps: 2, flats: 0, semitones: 2 },
      'A': { sharps: 3, flats: 0, semitones: 9 },
      'E': { sharps: 4, flats: 0, semitones: 4 },
      'B': { sharps: 5, flats: 0, semitones: 11 },
      'F#': { sharps: 6, flats: 0, semitones: 6 },
      'C#': { sharps: 7, flats: 0, semitones: 1 },
      'F': { sharps: 0, flats: 1, semitones: 5 },
      'Bb': { sharps: 0, flats: 2, semitones: 10 },
      'Eb': { sharps: 0, flats: 3, semitones: 3 },
      'Ab': { sharps: 0, flats: 4, semitones: 8 },
      'Db': { sharps: 0, flats: 5, semitones: 1 },
      'Gb': { sharps: 0, flats: 6, semitones: 6 },
      'Am': { sharps: 0, flats: 0, semitones: 9 },
      'Em': { sharps: 1, flats: 0, semitones: 4 },
      'Bm': { sharps: 2, flats: 0, semitones: 11 },
      'F#m': { sharps: 3, flats: 0, semitones: 6 },
      'C#m': { sharps: 4, flats: 0, semitones: 1 },
      'G#m': { sharps: 5, flats: 0, semitones: 8 },
      'D#m': { sharps: 6, flats: 0, semitones: 3 },
      'A#m': { sharps: 7, flats: 0, semitones: 10 },
      'Dm': { sharps: 0, flats: 1, semitones: 2 },
      'Gm': { sharps: 0, flats: 2, semitones: 7 },
      'Cm': { sharps: 0, flats: 3, semitones: 0 },
      'Fm': { sharps: 0, flats: 4, semitones: 5 },
      'Bbm': { sharps: 0, flats: 5, semitones: 10 },
      'Ebm': { sharps: 0, flats: 6, semitones: 3 }
    };

    // ====== HELPER FUNCTIONS ======
    function getInstrumentIcon(trackName, isPercussion) {
      const name = (trackName || '').toLowerCase();
      let icon = '🎵', className = '';

      if (isPercussion || name.includes('drum') || name.includes('percussion') || name.includes('kit')) {
        icon = '🥁';
        className = 'drums';
      } else if (name.includes('guitar') || name.includes('gtr')) {
        icon = '🎸';
        className = name.includes('bass') ? 'bass' : 'guitar';
      } else if (name.includes('piano') || name.includes('keyboard') || name.includes('keys')) {
        icon = '🎹';
        className = 'piano';
      } else if (name.includes('vocal') || name.includes('voice') || name.includes('singer')) {
        icon = '🎤';
        className = 'vocals';
      } else if (name.includes('bass') && !name.includes('guitar')) {
        icon = '🎸';
        className = 'bass';
      }
      return { icon, className };
    }

    function getInstrumentType(trackName, isPercussion) {
      const name = (trackName || '').toLowerCase();
      if (isPercussion || name.includes('drum') || name.includes('percussion')) {
        return 'Percussion';
      } else if (name.includes('bass') && !name.includes('guitar')) {
        return 'Rhythm Section';
      } else if (name.includes('guitar') && !name.includes('bass')) {
        return 'Guitar';
      } else if (name.includes('piano') || name.includes('keyboard') || name.includes('keys')) {
        return 'Keys';
      } else if (name.includes('vocal') || name.includes('voice')) {
        return 'Vocals';
      }
      return 'Instrument';
    }

    // ====== SCROLL CONTROL ======
    const origScrollFuncs = {
      siv: Element.prototype.scrollIntoView,
      st: window.scrollTo,
      sb: window.scrollBy
    };

    function applyScrollControl() {
      const enabled = AppState.autoScrollEnabled;
      Element.prototype.scrollIntoView = enabled ? origScrollFuncs.siv : function () { };
      window.scrollTo = enabled ? origScrollFuncs.st : function () { };
      window.scrollBy = enabled ? origScrollFuncs.sb : function () { };

      // Keep page pinned to top
      const se = document.scrollingElement || document.documentElement || document.body;
      if (!enabled) {
        se.scrollTop = 0;
        se.scrollLeft = 0;
      }
    }

    // Auto-follow inside sheet viewport
    function autoFollowPlayhead() {
      const VP_ID = 'alphaTab';
      const LOOKAHEAD_RATIO = 0.05;
      const STICKY_TOP = 20;
      const SMOOTH = 0.05;
      const DEAD_BAND = 10;

      const view = $('#' + VP_ID);
      const cursor = view && (view.querySelector('.at-cursor-beat') || view.querySelector('.at-cursor-bar'));

      if (view && cursor && AppState.autoScrollEnabled) {
        const vr = view.getBoundingClientRect();
        const cr = cursor.getBoundingClientRect();
        const targetY = STICKY_TOP + (vr.height - STICKY_TOP) * LOOKAHEAD_RATIO;
        const curYIn = cr.top - vr.top;
        let delta = curYIn - targetY;

        if (Math.abs(delta) > DEAD_BAND) {
          view.scrollTop += delta * SMOOTH;
        }
      }
      requestAnimationFrame(autoFollowPlayhead);
    }

    // ====== UI CONTROL FUNCTIONS ======
    function updateButtonStates() {
      // Transport buttons
      ['play', 'pause', 'stop'].forEach(id => {
        const el = $('#' + id);
        if (el) {
          if (id === 'play') el.classList.toggle('active', AppState.isPlaying);
          if (id === 'pause') el.classList.toggle('active', !AppState.isPlaying && at.timePosition > 0);
          if (id === 'stop') el.classList.toggle('active', !AppState.isPlaying && at.timePosition === 0);
        }
      });

      // Count-In & Metronome
      const ci = $('#countIn');
      const mt = $('#metronome');
      if (ci && at) ci.classList.toggle('active', (at.countInVolume || 0) > 0);
      if (mt) mt.classList.toggle('active', metronomeSettings.enabled);
    }

    function alignUIElements() {
      const header = $('header');
      const sidebar = $('.sidebar');
      const firstRowControls = $('.row-first-controls');
      const leftCluster = $('.row-second-left');
      const playBtn = $('#play');
      const recGroup = $('.row-second-rec');

      if (!header || !sidebar) return;

      // Check if we're on a small screen
      const isSmallScreen = window.innerWidth < 900;

      if (isSmallScreen) {
        // Reset all offsets on small screens
        header.style.setProperty('--first-row-offset', '0px');
        header.style.setProperty('--left-cluster-offset', '0px');
        header.style.setProperty('--record-offset', '0px');
        return;
      }

      const sidebarWidth = sidebar.getBoundingClientRect().width;
      const headerWidth = header.getBoundingClientRect().width;

      // First row offset
      if (firstRowControls) {
        let offset = Math.max(0, Math.round(sidebarWidth));
        const maxOffset = Math.max(0, Math.round((headerWidth - firstRowControls.scrollWidth) - 24));
        if (offset > maxOffset) offset = Math.max(0, maxOffset);
        header.style.setProperty('--first-row-offset', offset + 'px');
      }

      // Second row left cluster
      if (leftCluster) {
        let offset = Math.max(0, Math.round(sidebarWidth));
        const maxOffset = Math.max(0, Math.round((headerWidth - leftCluster.scrollWidth) - 24));
        if (offset > maxOffset) offset = Math.max(0, maxOffset);
        header.style.setProperty('--left-cluster-offset', offset + 'px');
      }

      // Record button alignment
      if (playBtn && recGroup) {
        const hr = header.getBoundingClientRect();
        const pr = playBtn.getBoundingClientRect();
        let offset = Math.max(0, Math.round(pr.left - hr.left));
        const maxOffset = Math.max(0, Math.round((hr.width - recGroup.getBoundingClientRect().width) - 24));
        if (offset > maxOffset) offset = Math.max(0, maxOffset);
        header.style.setProperty('--record-offset', offset + 'px');
      }
    }

    // ====== TRACK RENDERING ======
    function renderTrackList(score) {
      const cont = $('#tracks');
      cont.innerHTML = '';

      (score.tracks || []).forEach((t, idx) => {
        const row = document.createElement('div');
        row.className = 'track';
        row.setAttribute('data-track-index', String(idx));

        const instrumentData = getInstrumentIcon(t.name || '', t.isPercussion);
        const instrumentType = getInstrumentType(t.name || '', t.isPercussion);

        row.innerHTML = `
      <div class="instrument-icon ${instrumentData.className}">${instrumentData.icon}</div>
      <div class="track-info">
        <div class="track-name">${t.name || ('Track ' + (idx + 1))}</div>
        <div class="track-type">${instrumentType}</div>
      </div>
      <div class="track-controls">
        <input type="checkbox" class="render" title="Render this track">
        <div class="control-group">
          <button class="btn solo" title="Solo">S</button>
          <button class="btn mute" title="Mute">M</button>
        </div>
      </div>`;

        // Event handlers
        const renderCb = row.querySelector('.render');
        renderCb.addEventListener('change', () => {
          const selected = [...$$('.track .render:checked')].map(cb => {
            const i = [...cont.children].indexOf(cb.closest('.track'));
            return at.score.tracks[i];
          });
          if (selected.length === 0) {
            at.renderTracks([at.score.tracks[0]]);
            cont.querySelector('.track .render').checked = true;
          } else {
            at.renderTracks(selected);
          }
        });

        // Solo/Mute with state tracking
        const state = AppState.trackStates[idx] || {};
        const soloBtn = row.querySelector('.solo');
        const muteBtn = row.querySelector('.mute');

        soloBtn.classList.toggle('active', !!state.solo);
        muteBtn.classList.toggle('active', !!state.mute);

        soloBtn.onclick = () => {
          const on = !soloBtn.classList.contains('active');
          try { at.changeTrackSolo([at.score.tracks[idx]], on); } catch (e) { }
          soloBtn.classList.toggle('active', on);
          AppState.trackStates[idx] = AppState.trackStates[idx] || {};
          AppState.trackStates[idx].solo = on;
        };

        muteBtn.onclick = () => {
          const on = !muteBtn.classList.contains('active');
          try { at.changeTrackMute([at.score.tracks[idx]], on); } catch (e) { }
          muteBtn.classList.toggle('active', on);
          AppState.trackStates[idx] = AppState.trackStates[idx] || {};
          AppState.trackStates[idx].mute = on;
        };

        cont.appendChild(row);
      });

      // Render first track by default
      if (at.score.tracks?.length) {
        at.renderTracks([at.score.tracks[0]]);
        $$('.track .render')[0].checked = true;
      }
    }

    // Track highlighting on play
    const trackHighlightTimers = {};
    function highlightPlayingTrack(idx) {
      const row = $(`.track[data-track-index="${idx}"]`);
      if (!row) return;
      row.classList.add('playing');
      if (trackHighlightTimers[idx]) clearTimeout(trackHighlightTimers[idx]);
      trackHighlightTimers[idx] = setTimeout(() => {
        row.classList.remove('playing');
        delete trackHighlightTimers[idx];
      }, 300);
    }

    function clearAllPlayingTracks() {
      $$('.track.playing').forEach(row => row.classList.remove('playing'));
      Object.values(trackHighlightTimers).forEach(timer => clearTimeout(timer));
      Object.keys(trackHighlightTimers).forEach(k => delete trackHighlightTimers[k]);
    }

    // ====== KEY DETECTION AND TRANSPOSITION ======
    function keySignatureToKey(keySignature) {
      if (typeof keySignature !== 'number') return 'C';
      const keyMap = {
        0: 'C', 1: 'G', 2: 'D', 3: 'A', 4: 'E', 5: 'B', 6: 'F#', 7: 'C#',
        [-1]: 'F', [-2]: 'Bb', [-3]: 'Eb', [-4]: 'Ab', [-5]: 'Db', [-6]: 'Gb', [-7]: 'Cb'
      };
      return keyMap[keySignature] || 'C';
    }

    function keyToKeySignature(keyName) {
      const keyToNumber = {
        'C': 0, 'G': 1, 'D': 2, 'A': 3, 'E': 4, 'B': 5, 'F#': 6, 'C#': 7,
        'F': -1, 'Bb': -2, 'Eb': -3, 'Ab': -4, 'Db': -5, 'Gb': -6,
        'Am': 0, 'Em': 1, 'Bm': 2, 'F#m': 3, 'C#m': 4, 'G#m': 5, 'D#m': 6, 'A#m': 7,
        'Dm': -1, 'Gm': -2, 'Cm': -3, 'Fm': -4, 'Bbm': -5, 'Ebm': -6
      };
      return keyToNumber[keyName] || 0;
    }

    function detectKeyFromScore(score) {
      try {
        // Check various locations for key signature
        if (score?.keySignature !== undefined && score.keySignature !== null) {
          return keySignatureToKey(score.keySignature);
        }

        if (score?.masterBars?.length > 0) {
          for (let i = 0; i < Math.min(5, score.masterBars.length); i++) {
            const mb = score.masterBars[i];
            if (mb && typeof mb.keySignature === 'number') {
              return keySignatureToKey(mb.keySignature);
            }
          }
        }

        if (score?.tracks?.length > 0) {
          for (const track of score.tracks) {
            if (track?.staves?.length > 0) {
              for (const staff of track.staves) {
                if (staff?.bars?.length > 0) {
                  for (let i = 0; i < Math.min(3, staff.bars.length); i++) {
                    const bar = staff.bars[i];
                    if (bar && typeof bar.keySignature === 'number') {
                      return keySignatureToKey(bar.keySignature);
                    }
                  }
                }
              }
            }
          }
        }
      } catch (e) {
        console.error('Error in key detection:', e);
      }
      return 'C';
    }

    function updateKeyDisplay(key) {
      AppState.currentKey = key;
      $('#keyBtn').textContent = `Key: ${key}`;

      $$('.key-option').forEach(opt => {
        opt.classList.remove('current');
        if (opt.dataset.key === key) {
          opt.classList.add('current');
        }
      });
    }

    function updateScoreKeySignatures(score, newKeySignature) {
      let updatedCount = 0;

      try {
        if (score.keySignature !== undefined) {
          score.keySignature = newKeySignature;
          updatedCount++;
        }

        if (score.masterBars?.length > 0) {
          for (const mb of score.masterBars) {
            if (mb && typeof mb.keySignature === 'number') {
              mb.keySignature = newKeySignature;
              updatedCount++;
            }
          }
        }

        if (score.tracks?.length > 0) {
          for (const track of score.tracks) {
            if (track.staves?.length > 0) {
              for (const staff of track.staves) {
                if (staff.bars?.length > 0) {
                  for (const bar of staff.bars) {
                    if (bar && typeof bar.keySignature === 'number') {
                      bar.keySignature = newKeySignature;
                      updatedCount++;
                    }
                  }
                }
              }
            }
          }
        }

        log(`Total key signature updates: ${updatedCount}`);
        return updatedCount > 0;
      } catch (e) {
        console.error('Error updating key signatures:', e);
        return false;
      }
    }

    function transposeToKey(targetKey) {
      if (!at || !at.score) {
        log('Cannot transpose: no score loaded');
        return;
      }

      const originalSemitones = keySignatures[AppState.originalKey]?.semitones || 0;
      const targetSemitones = keySignatures[targetKey]?.semitones || 0;

      updateKeyDisplay(targetKey);

      // Calculate semitones difference
      let transposition = targetSemitones - originalSemitones;

      // Respect transpose toggle
      const transposeToggle = $('#transposeToggle');
      const doTranspose = !!(transposeToggle && transposeToggle.checked);
      if (!doTranspose) transposition = 0;

      // Normalize to [-6, 6] range
      while (transposition > 11) transposition -= 12;
      while (transposition < -11) transposition += 12;

      const newKeySignature = keyToKeySignature(targetKey);
      AppState.currentTransposition = transposition;

      log(`🎵 Transposing from ${AppState.originalKey} to ${targetKey}`);
      if (!doTranspose) log('✏️ Rewrite-only mode: pitches unchanged');

      try {
        const wasPlaying = AppState.isPlaying;
        const currentMs = at.timePosition || 0;
        const currentTracks = at.tracks || [];

        // Update key signatures in score
        updateScoreKeySignatures(at.score, newKeySignature);

        // Apply note transposition
        const numTracks = at.score.tracks.length;
        const transpositionArray = new Array(numTracks).fill(transposition);
        at.settings.notation.transpositionPitches = transpositionArray;

        // Apply live playback transposition
        try {
          if (at.changeTrackTranspositionPitch && at.score?.tracks?.length) {
            at.changeTrackTranspositionPitch(at.score.tracks, transposition);
          }
        } catch (e) { /* ignore */ }

        at.updateSettings();

        // Re-render tracks
        if (currentTracks.length > 0) {
          at.renderTracks(currentTracks);
        } else {
          at.renderTracks([at.score.tracks[0]]);
          setTimeout(() => {
            const firstCheckbox = $('.track .render');
            if (firstCheckbox) firstCheckbox.checked = true;
          }, 100);
        }

        // Resume playback if needed
        if (wasPlaying) {
          at.stop();
          at.timePosition = currentMs;
          at.play();
        }

        log(`✅ Transposition applied successfully!`);
      } catch (e) {
        console.error('Transposition failed:', e);
        log('❌ Transposition failed: ' + e.message);
      }
    }

    // ====== TRANSPORT CONTROLS ======
    $('#play').onclick = () => {
      at.play();
      AppState.isPlaying = true;

      // Start metronome if it's pre-enabled
      if (metronomeSettings.enabled && !customMetronome.isPlaying) {
        customMetronome.setVolume(metronomeSettings.volume);
        customMetronome.setSubdivision(metronomeSettings.subdivision);
        customMetronome.start();
      }

      updateButtonStates();
    };

    $('#pause').onclick = () => {
      at.pause();
      AppState.isPlaying = false;

      // Stop metronome when pausing
      if (customMetronome.isPlaying) {
        customMetronome.stop();
      }

      updateButtonStates();
    };

    $('#stop').onclick = () => {
      at.stop();
      at.timePosition = 0;
      AppState.isPlaying = false;

      // Stop metronome when stopping
      if (customMetronome.isPlaying) {
        customMetronome.stop();
      }

      updateButtonStates();
    };
    $('#speed').addEventListener('input', (e) => {
      const newSpeed = parseFloat(e.target.value);
      at.playbackSpeed = newSpeed;

      // Update speed display
      const speedPercent = Math.round(newSpeed * 100);
      const speedDisplay = $('#speedDisplay');
      if (speedDisplay) {
        speedDisplay.textContent = speedPercent + '%';
      }

      // Update BPM button if exists
      const bpmBtn = $('#bpmBtn');
      if (bpmBtn) {
        // Use the base tempo if set, otherwise use default 120
        const baseTempo = customMetronome.baseTempo || 120;
        const currentBPM = Math.round(baseTempo * newSpeed);
        bpmBtn.textContent = `BPM: ${currentBPM}`;

        // Make sure button is visible if it has content
        if (bpmBtn.style.display === 'none') {
          bpmBtn.style.display = 'inline-flex';
        }
      }

      // Update metronome tempo if it's running
      if (customMetronome.isPlaying) {
        customMetronome.stop();
        customMetronome.start();
      }
    });

    $('#countIn').onclick = () => {
      at.countInVolume = at.countInVolume > 0 ? 0 : 1;
      AppState.preservedCountInVolume = at.countInVolume;
      updateButtonStates();
    };

    // Custom metronome with real subdivisions (ADD THIS STARTING AT LINE 2030)
    class WorkingMetronome {
      constructor() {
        this.audioContext = null;
        this.isPlaying = false;
        this.nextNoteTime = 0;
        this.currentBeat = 0;
        this.tempo = 120;
        this.baseTempo = 120;
        this.subdivision = 1;
        this.volume = 0.7;
        this.soundType = 'click';
        this.timerID = null;
      }

      init() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      }

      playClick(time, strong = false) {
        const osc = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();

        osc.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        switch (this.soundType) {
          case 'beep':
            osc.frequency.value = strong ? 1200 : 900;
            gainNode.gain.value = this.volume * (strong ? 1 : 0.7);
            osc.start(time);
            osc.stop(time + 0.08);
            break;

          case 'tick':
            osc.type = 'square';
            osc.frequency.value = strong ? 2500 : 2000;
            gainNode.gain.value = this.volume * (strong ? 0.8 : 0.4);
            osc.start(time);
            osc.stop(time + 0.01);
            break;

          case 'woodblock':
            const noise = this.audioContext.createOscillator();
            noise.type = 'square';
            noise.frequency.value = strong ? 800 : 600;
            noise.connect(gainNode);
            gainNode.gain.value = this.volume * (strong ? 1 : 0.5);
            gainNode.gain.exponentialRampToValueAtTime(0.01, time + 0.03);
            noise.start(time);
            noise.stop(time + 0.03);
            break;

          case 'cowbell':
            osc.type = 'triangle';
            osc.frequency.value = strong ? 560 : 420;
            const osc2 = this.audioContext.createOscillator();
            osc2.type = 'triangle';
            osc2.frequency.value = strong ? 845 : 635;
            osc2.connect(gainNode);
            gainNode.gain.value = this.volume * (strong ? 0.9 : 0.5);
            gainNode.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
            osc.start(time);
            osc2.start(time);
            osc.stop(time + 0.15);
            osc2.stop(time + 0.15);
            break;

          case 'click':
          default:
            osc.frequency.value = strong ? 1000 : 800;
            gainNode.gain.value = this.volume * (strong ? 1 : 0.5);
            osc.start(time);
            osc.stop(time + 0.05);
            break;
        }
      }

      scheduler() {
        const lookahead = 0.1;

        while (this.nextNoteTime < this.audioContext.currentTime + lookahead) {
          const beatLength = 60.0 / this.tempo;
          let noteLength;

          if (this.subdivision < 1) {
            // For half and whole notes - subdivisions less than 1
            noteLength = beatLength / this.subdivision;
          } else {
            // For quarter, eighth, triplet, sixteenth
            noteLength = beatLength / this.subdivision;
          }

          // Determine if this is a strong beat
          let isDownbeat = false;
          if (this.subdivision >= 1) {
            // Normal subdivisions
            isDownbeat = (this.currentBeat % this.subdivision) === 0;
          } else if (this.subdivision === 0.5) {
            // Half notes - every 2 beats
            isDownbeat = (this.currentBeat % 2) === 0;
          } else if (this.subdivision === 0.25) {
            // Whole notes - every 4 beats  
            isDownbeat = (this.currentBeat % 4) === 0;
          }

          // Only play click for the appropriate pattern
          if (this.subdivision >= 1 || isDownbeat) {
            this.playClick(this.nextNoteTime, isDownbeat);
          }

          this.nextNoteTime += noteLength;
          this.currentBeat++;

          // Reset beat counter appropriately
          if (this.subdivision >= 1) {
            if (this.currentBeat >= this.subdivision * 4) {
              this.currentBeat = 0;
            }
          } else {
            if (this.currentBeat >= 16) {  // Reset after 4 measures
              this.currentBeat = 0;
            }
          }
        }

        this.timerID = setTimeout(() => this.scheduler(), 25);
      }

      start() {
        if (!this.audioContext) this.init();
        // Use the detected song BPM adjusted by playback speed
        if (at && at.playbackSpeed) {
          this.tempo = this.baseTempo * at.playbackSpeed;
        } else {
          this.tempo = this.baseTempo;
        }
        this.isPlaying = true;
        this.currentBeat = 0;
        this.nextNoteTime = this.audioContext.currentTime;
        this.scheduler();
      }

      stop() {
        this.isPlaying = false;
        clearTimeout(this.timerID);
      }

      setSubdivision(value) {
        this.subdivision = value;
        this.currentBeat = 0;
      }

      setVolume(value) {
        this.volume = value;
      }

      setSoundType(type) {
        this.soundType = type;
      }
    }

    const customMetronome = new WorkingMetronome();
    window.customMetronome = customMetronome;

    // Enhanced Metronome with settings (EXISTING CODE STARTS HERE)

    // Enhanced Metronome with settings
    (function () {
      const btn = $('#metronome');
      const panel = $('#metronomeSettings');
      const volumeSlider = $('#metronomeVolume');
      const volumeLabel = $('#metronomeVolumeLabel');
      const subdivisionSelect = $('#metronomeSubdivision');

      // Main toggle
      btn.onclick = (e) => {
        e.stopPropagation();
        metronomeSettings.enabled = !metronomeSettings.enabled;
        btn.classList.toggle('active', metronomeSettings.enabled);

        // Turn off AlphaTab's metronome
        at.metronomeVolume = 0.001;

        // Check if PDF is scrolling
        const pdfScrollBtn = $('#pdfScrollToggle');
        const isPdfScrolling = pdfScrollBtn && pdfScrollBtn.getAttribute('aria-pressed') === 'true';

        // Start/stop metronome based on either song playing or PDF scrolling
        if (AppState.isPlaying || isPdfScrolling) {
          if (metronomeSettings.enabled && !customMetronome.isPlaying) {
            customMetronome.setVolume(metronomeSettings.volume);
            customMetronome.setSubdivision(metronomeSettings.subdivision);
            customMetronome.start();
          }
        }
        // Always stop if disabled, regardless of playback state
        if (!metronomeSettings.enabled && customMetronome.isPlaying) {
          customMetronome.stop();
        }

        updateButtonStates();
      };

      // Show settings on right-click
      btn.oncontextmenu = (e) => {
        e.preventDefault();
        e.stopPropagation();
        panel.classList.toggle('show');
      };

      // Add settings indicator
      btn.innerHTML = btn.textContent + ' <span style="font-size:8px;opacity:0.5">⚙</span>';

      // ADD THIS TOOLTIP AND STYLING
      btn.title = "Click to toggle ON/OFF | Right-click for volume & settings";
      btn.style.cursor = 'pointer';

      // Make the gear icon more visible and clickable
      const gearSpan = btn.querySelector('span');
      if (gearSpan) {
        gearSpan.style.opacity = '0.8';  // More visible than 0.5
        gearSpan.style.fontSize = '8px';  // Slightly bigger
        gearSpan.style.marginLeft = '2px';
        gearSpan.title = 'Right-click for settings';
      }

      // Volume control
      if (volumeSlider) {
        volumeSlider.oninput = (e) => {
          const value = parseInt(e.target.value);
          metronomeSettings.volume = value / 100;
          volumeLabel.textContent = value + '%';

          // Update custom metronome volume
          customMetronome.setVolume(metronomeSettings.volume);
        };
      }

      // Subdivision control (NOW WORKING!)
      if (subdivisionSelect) {
        subdivisionSelect.onchange = (e) => {
          metronomeSettings.subdivision = parseFloat(e.target.value);
          customMetronome.setSubdivision(metronomeSettings.subdivision);
        };
      }

      // Sound type control
      const soundSelect = $('#metronomeSound');
      if (soundSelect) {
        soundSelect.onchange = (e) => {
          const soundType = e.target.value;
          customMetronome.setSoundType(soundType);
          metronomeSettings.soundType = soundType;
        };
      }

      // Close panel when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('#metronome') && !e.target.closest('#metronomeSettings')) {
          panel?.classList.remove('show');
        }
      });
    })();

    // BPM Display only (no adjustment)
    (function () {
      const bpmBtn = $('#bpmBtn');
      if (!bpmBtn) return;

      // Just keep the button as a display, no click functionality
      bpmBtn.style.cursor = 'default';
    })();

    $('#autoScroll').onchange = e => {  // <-- This is the next existing code around line 2143
      AppState.autoScrollEnabled = e.target.checked;
      applyScrollControl();
    };

    // ====== KEY SELECTOR ======
    $('#keyBtn').onclick = (e) => {
      e.stopPropagation();
      const dropdown = $('#keyDropdown');
      let root = $('#ui-overlay-root');
      if (!root) {
        root = document.createElement('div');
        root.id = 'ui-overlay-root';
        root.setAttribute('aria-hidden', 'true');
        document.body.appendChild(root);
      }
      const r = e.currentTarget.getBoundingClientRect();
      dropdown.style.left = Math.round(Math.max(8, Math.min(r.left, window.innerWidth - r.width - 8))) + 'px';
      dropdown.style.top = Math.round(r.bottom + 4) + 'px';
      dropdown.style.minWidth = Math.round(r.width) + 'px';
      dropdown.classList.add('dropdown-layer');
      root.appendChild(dropdown);
      dropdown.classList.toggle('show');
    };

    document.addEventListener('click', (e) => {
      const dropdown = $('#keyDropdown');
      if (!e.target.closest('.key-selector') && !e.target.closest('#ui-overlay-root')) {
        dropdown.classList.remove('show');
        const parent = $('.key-selector');
        if (parent && dropdown && parent !== dropdown.parentElement) {
          parent.appendChild(dropdown);
          dropdown.classList.remove('dropdown-layer');
          dropdown.style.left = dropdown.style.top = dropdown.style.minWidth = '';
        }
      }
    });

    $$('.key-option').forEach(option => {
      option.onclick = () => {
        const selectedKey = option.dataset.key;
        log(`🎵 User selected key: ${selectedKey}`);
        transposeToKey(selectedKey);
        $('#keyDropdown').classList.remove('show');
        const dd = $('#keyDropdown');
        const parent = $('.key-selector');
        if (parent && dd && parent !== dd.parentElement) {
          parent.appendChild(dd);
          dd.classList.remove('dropdown-layer');
          dd.style.left = dd.style.top = dd.style.minWidth = '';
        }
      };
    });

    // ====== ALPHATAB EVENT HANDLERS ======
    at.scoreLoaded.on(score => {

      // RESTORE AUDIO STATE if it was disabled (e.g., after loading a PDF)
      try {
        if (at?.player) {
          // Re-enable master volume
          if (at.player.masterVolume !== undefined) {
            at.player.masterVolume = 1.0;
          }
          // Ensure player is not stuck in stopped state
          if (typeof at.player.resetSynthesizer === 'function') {
            at.player.resetSynthesizer();
          }
          // Re-initialize soundfont if needed
          if (at.player.soundFont && typeof at.player.soundFont.init === 'function') {
            at.player.soundFont.init();
          }
        }
      } catch (e) { console.log('Audio restore:', e); }

      // Clear any pending scroll reset when loading new score
      if (window.scrollResetTimer) {
        clearTimeout(window.scrollResetTimer);
        window.scrollResetTimer = null;
      }
      $('#meta').textContent = `${score.title || 'Untitled'} — ${score.artist || 'Unknown'} (${score.tracks?.length || 0} tracks)`;

      AppState.isPlaying = false;
      AppState.currentTransposition = 0;

      // Reset transposition settings
      try {
        const numTracks = score.tracks?.length || 1;
        at.settings.notation.transpositionPitches = new Array(numTracks).fill(0);
        if (at.changeTrackTranspositionPitch && at.score?.tracks?.length) {
          at.changeTrackTranspositionPitch(at.score.tracks, 0);
        }
        at.updateSettings();
      } catch (e) { /* ignore */ }

      // Reset playback speed to 100% when loading new score
      at.playbackSpeed = 1.0;
      const speedSelect = $('#speed');
      if (speedSelect) {
        speedSelect.value = '1';
      }

      // Detect key
      const detectedKey = detectKeyFromScore(score);
      AppState.originalKey = detectedKey;
      AppState.currentKey = detectedKey;
      updateKeyDisplay(detectedKey);

      renderTrackList(score);
      log(`🎼 Score loaded: ${score.title || 'Untitled'}`);
      log(`🎹 Detected key: ${detectedKey}`);

      // Extract and set BPM from the score
      let songBPM = 120; // default
      try {
        // Check for tempo in score
        if (score.tempo) {
          songBPM = score.tempo;
        } else if (score.masterBars && score.masterBars[0]) {
          // Look for tempo in first master bar
          const firstBar = score.masterBars[0];
          if (firstBar.tempoAutomation) {
            songBPM = firstBar.tempoAutomation.value;
          } else if (firstBar.tempo) {
            songBPM = firstBar.tempo;
          }
        }

        // Update metronome's base tempo
        customMetronome.baseTempo = songBPM;
        log(`🎵 Song BPM detected: ${songBPM}`);

        // Update BPM button
        const bpmBtn = $('#bpmBtn');
        if (bpmBtn) {
          bpmBtn.style.display = 'inline-flex';
          bpmBtn.textContent = `BPM: ${songBPM}`;
        }

      } catch (e) {
        console.log('Could not detect BPM, using default 120');
      }

      // Restore metronome/count-in after score load
      setTimeout(() => {
        if (AppState.preservedMetronomeVolume > 0) {
          at.metronomeVolume = AppState.preservedMetronomeVolume;
        }
        if (AppState.preservedCountInVolume > 0) {
          at.countInVolume = AppState.preservedCountInVolume;
        }
        updateButtonStates();
      }, 100);
    });
    // Reset scroll when rendering finishes (fixed to prevent vibration)
    at.renderFinished.on(() => {
      const alphaTab = $('#alphaTab');
      if (!alphaTab) return;

      // Clear any existing timer to prevent conflicts
      if (window.scrollResetTimer) {
        clearTimeout(window.scrollResetTimer);
      }

      // Single delayed reset instead of multiple aggressive ones
      window.scrollResetTimer = setTimeout(() => {
        if (alphaTab && !AppState.isPlaying) {
          alphaTab.scrollTop = 0;
          alphaTab.scrollLeft = 0;
        }
      }, 150); // Single delay, adjusted for stability
    });

    at.playerPositionChanged.on(e => {
      const fmt = ms => {
        const s = Math.floor(ms / 1000), m = (s / 60 | 0), ss = String(s % 60).padStart(2, '0');
        return `${m}:${ss}`;
      };
      $('#time').textContent = `${fmt(e.currentTime)} / ${fmt(e.endTime)}`;
    });

    // Player state tracking
    try {
      at.player.stateChanged?.on?.((state) => {
        AppState.isPlaying = (state === 1);  // 1 = playing
        if (state === 0) {  // 0 = stopped
          at.timePosition = 0;
        }
        updateButtonStates();
        if (state !== 1) clearAllPlayingTracks();
      });
    } catch (e) { }

    // MIDI event highlighting
    at.midiEventsPlayedFilter = [alphaTab.midi.MidiEventType.NoteOn];
    at.midiEventsPlayed.on(ev => {
      // Track highlighting
      const seen = new Set();
      (ev?.events || []).forEach(me => {
        const idx = me?.track;  // The track property IS the index

        if (typeof idx === 'number' && idx >= 0) {
          if (!seen.has(idx)) {
            seen.add(idx);
            highlightPlayingTrack(idx);
          }
        }
      });
    });

    // ====== FILE INPUT ======
    $('#fileInput').addEventListener('change', async e => {
      const f = e.target.files?.[0];
      if (!f) return;

      const name = f.name.toLowerCase();

      // Restrict disallowed file types (MIDI & Capella)
      const forbiddenExts = ['.mid', '.midi', '.cap', '.capx'];
      if (forbiddenExts.some(ext => name.endsWith(ext))) {
        alert('This player does not allow MIDI (.mid, .midi) or Capella (.cap, .capx) files. Please load Guitar Pro, MusicXML, or PDF.');
        try { log('❌ Blocked unsupported file type: ' + f.name); } catch (_) { }
        e.target.value = '';
        return;
      }
      const buf = await f.arrayBuffer();

      window.currentScoreBuffer = buf;
      window.currentFileName = f.name;

      log(`📁 Loading file: ${f.name}`);

      if (name.endsWith('.mid') || name.endsWith('.midi')) {
        try {
          log('🎵 Converting MIDI to MusicXML...');
          const xml = midiToMusicXmlWithTab(new Midi(buf), {
            quant: parseInt($('#quant').value, 10) || 8,
            tsNum: parseInt($('#tsNum').value, 10) || 4,
            tsDen: parseInt($('#tsDen').value, 10) || 4,
            merge: $('#merge').checked,
            includePerc: $('#includePerc').checked
          });
          const blob = new Blob([xml], { type: 'application/vnd.recordare.musicxml+xml' });
          const xmlBuffer = await blob.arrayBuffer();
          window.currentScoreBuffer = xmlBuffer;

          await at.load(xmlBuffer);
          log('✔ MIDI converted and loaded successfully');
        } catch (err) {
          log('❌ MIDI conversion failed: ' + err.message);
          alert('Could not convert MIDI. Try a different quantization/time signature, or export MusicXML from your DAW.');
        }
      } else {
        try {
          // Re-enable transport controls when loading a song
          const playBtn = $('#play');
          const pauseBtn = $('#pause');
          const stopBtn = $('#stop');
          [playBtn, pauseBtn, stopBtn].forEach(btn => {
            if (btn) {
              btn.disabled = false;
              btn.style.opacity = '1';
            }
          });
          await at.load(buf);
          log('✔ File loaded successfully');
        } catch (err) {
          log('❌ Load error: ' + err.message);
        }
      }
    });

    $('#loadFileBtn').onclick = () => $('#fileInput').click();

    // ====== MIDI TO MUSICXML CONVERTER ======
    function midiToMusicXmlWithTab(midi, opts) {
      const ppq = midi.header.ppq || 480;
      const divisions = opts.quant || 8;
      const tsN = opts.tsNum || 4, tsD = opts.tsDen || 4;
      const includePerc = !!opts.includePerc;
      const merge = !!opts.merge;
      const bpm = (midi.header.tempos && midi.header.tempos[0] && midi.header.tempos[0].bpm) ? Math.round(midi.header.tempos[0].bpm) : 120;

      const tuningMidi = [64, 59, 55, 50, 45, 40];

      const parts = [];
      if (merge) {
        const all = [];
        midi.tracks.forEach((t, ti) => {
          const ch = (typeof t.channel === 'number') ? t.channel : null;
          if (!includePerc && ch === 9) return;
          (t.notes || []).forEach(n => all.push({ ...n, track: ti }));
        });
        parts.push({ id: 'P1', name: 'Merged', notes: all });
      } else {
        let idx = 1;
        midi.tracks.forEach((t, ti) => {
          if (!t.notes || !t.notes.length) return;
          const ch = (typeof t.channel === 'number') ? t.channel : null;
          if (!includePerc && ch === 9) return;
          parts.push({ id: 'P' + (idx++), name: t.name || ('Track ' + (ti + 1)), notes: t.notes.slice() });
        });
      }

      function qTicksToDiv(ticks) { return Math.max(1, Math.round((ticks / ppq) * divisions)); }
      function midiToPitch(m) {
        const names = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const sFull = names[m % 12];
        const step = sFull.replace('#', '');
        const alter = sFull.includes('#') ? 1 : 0;
        const octave = (m / 12 | 0) - 1;
        return { step, alter, octave };
      }
      function durationType(divs) {
        const ratio = divs / divisions;
        const map = { 4: 'whole', 2: 'half', 1: 'quarter', 0.5: 'eighth', 0.25: '16th', 0.125: '32nd' };
        for (const k of Object.keys(map)) {
          if (Math.abs(ratio - parseFloat(k)) < 1e-6) return map[k];
        }
        return null;
      }
      const measDiv = Math.round(divisions * tsN * (4 / tsD));

      function quantize(notes) {
        return notes.map(n => ({
          start: qTicksToDiv(n.ticks),
          dur: Math.max(1, qTicksToDiv(n.durationTicks)),
          midi: n.midi | 0
        })).sort((a, b) => a.start - b.start || a.midi - b.midi);
      }

      function splitMeasures(qnotes) {
        const measures = [];
        let i = 0;
        while (i < qnotes.length) {
          const s = qnotes[i].start;
          const batch = [];
          while (i < qnotes.length && qnotes[i].start === s) {
            batch.push(qnotes[i]);
            i++;
          }
          const dur = Math.max(...batch.map(x => x.dur));
          let pos = s, remaining = dur;
          while (remaining > 0) {
            const mIndex = Math.floor(pos / measDiv);
            const mStart = mIndex * measDiv;
            const within = pos - mStart;
            const room = measDiv - within;
            const take = Math.min(remaining, room);
            if (!measures[mIndex]) measures[mIndex] = [];
            measures[mIndex].push({
              offset: within,
              dur: take,
              midis: batch.map(x => x.midi),
              tieStart: remaining > take,
              tieStop: within > 0 && take < dur
            });
            pos += take;
            remaining -= take;
          }
        }
        return measures;
      }

      function toStringFret(m) {
        let bestFret = Infinity, bestString = 1;
        for (let s = 0; s < 6; s++) {
          const fret = m - tuningMidi[s];
          if (fret >= 0 && fret <= 22) {
            if (fret < bestFret) {
              bestFret = fret;
              bestString = s + 1;
            }
          }
        }
        if (!isFinite(bestFret)) {
          const f = Math.max(0, m - tuningMidi[0]);
          return { string: 1, fret: f };
        }
        return { string: bestString, fret: bestFret };
      }

      function escapeXml(s) {
        return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
      }

      function tuningStaffDetails() {
        function stepOct(m) {
          const names = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
          const name = names[m % 12];
          const step = name.replace('#', '');
          const oct = (m / 12 | 0) - 1;
          return { step, oct: oct };
        }
        let lines = ['      <staff-details number="2"><staff-lines>6</staff-lines><staff-type>tab</staff-type>'];
        for (let i = 0; i < 6; i++) {
          const { step, oct } = stepOct(tuningMidi[i]);
          lines.push(`        <staff-tuning line="${i + 1}"><tuning-step>${step}</tuning-step><tuning-octave>${oct}</tuning-octave></staff-tuning>`);
        }
        lines.push('      </staff-details>');
        return lines.join('\n');
      }

      function emitHeader() {
        const title = midi.name ? escapeXml(midi.name) : 'MIDI Conversion';
        return [
          '<?xml version="1.0" encoding="UTF-8" standalone="no"?>',
          '<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">',
          '<score-partwise version="3.1">',
          `  <work><work-title>${title}</work-title></work>`,
          '  <identification><encoding><software>MIDI to MusicXML (client-side, with TAB)</software></encoding></identification>',
          '  <part-list>',
          ...parts.map(p => `    <score-part id="${p.id}"><part-name>${escapeXml(p.name)}</part-name></score-part>`),
          '  </part-list>'
        ].join('\n');
      }

      function emitAttributes() {
        return [
          '      <attributes>',
          `        <divisions>${divisions}</divisions>`,
          '        <staves>2</staves>',
          '        <clef number="1"><sign>G</sign><line>2</line></clef>',
          '        <clef number="2"><sign>TAB</sign><line>5</line></clef>',
          `        <time><beats>${tsN}</beats><beat-type>${tsD}</beat-type></time>`,
          tuningStaffDetails(),
          '      </attributes>',
          `      <direction placement="above"><direction-type><metronome><beat-unit>quarter</beat-unit><per-minute>${bpm}</per-minute></metronome></direction-type><sound tempo="${bpm}"/></direction>`
        ].join('\n');
      }

      function emitPart(p) {
        const q = quantize(p.notes || []);
        const measures = splitMeasures(q);
        let xml = `  <part id="${p.id}">\n`;
        const lastPos = q.length ? (q[q.length - 1].start + q[q.length - 1].dur) : 0;
        const totalMeasures = measures.length ? measures.length : (lastPos ? Math.ceil(lastPos / measDiv) : 1);
        for (let mi = 0; mi < totalMeasures; mi++) {
          xml += `    <measure number="${mi + 1}">\n`;
          if (mi === 0) xml += emitAttributes() + '\n';

          const raw = measures[mi] || [];
          const entries = raw.length ? raw.slice().sort((a, b) => a.offset - b.offset) : [];
          let j = 0;
          while (j < entries.length) {
            const off = entries[j].offset;
            const group = [];
            while (j < entries.length && entries[j].offset === off) {
              group.push(entries[j]);
              j++;
            }
            const chord = [...new Set(group.flatMap(g => g.midis))].sort((a, b) => a - b);
            const dur = Math.max(...group.map(g => g.dur));
            const tieStart = group.some(g => g.tieStart), tieStop = group.some(g => g.tieStop);

            if (chord.length === 0) {
              xml += '      <note>\n        <rest/>\n';
              xml += `        <duration>${dur}</duration>\n        <voice>1</voice>\n        <staff>1</staff>\n`;
              const typ = durationType(dur);
              if (typ) xml += `        <type>${typ}</type>\n`;
              xml += '      </note>\n';
            } else {
              // Staff 1 (notation)
              chord.forEach((m, idx) => {
                const pch = midiToPitch(m);
                xml += '      <note>\n';
                if (idx > 0) xml += '        <chord/>\n';
                xml += `        <pitch><step>${pch.step}</step>${pch.alter ? `<alter>${pch.alter}</alter>` : ''}<octave>${pch.octave}</octave></pitch>\n`;
                xml += `        <duration>${dur}</duration>\n        <voice>1</voice>\n        <staff>1</staff>\n`;
                const typ = durationType(dur);
                if (typ) xml += `        <type>${typ}</type>\n`;
                if (tieStop) xml += '        <tie type="stop"/>\n';
                if (tieStart) xml += '        <tie type="start"/>\n';
                if (tieStop || tieStart) {
                  xml += '        <notations>';
                  if (tieStop) xml += '<tied type="stop"/>';
                  if (tieStart) xml += '<tied type="start"/>';
                  xml += '</notations>\n';
                }
                xml += '      </note>\n';
              });
              // Staff 2 (TAB)
              chord.forEach((m, idx) => {
                const pch = midiToPitch(m);
                const sf = toStringFret(m);
                xml += '      <note>\n';
                if (idx > 0) xml += '        <chord/>\n';
                xml += `        <pitch><step>${pch.step}</step>${pch.alter ? `<alter>${pch.alter}</alter>` : ''}<octave>${pch.octave}</octave></pitch>\n`;
                xml += `        <duration>${dur}</duration>\n        <voice>2</voice>\n        <staff>2</staff>\n`;
                const typ = durationType(dur);
                if (typ) xml += `        <type>${typ}</type>\n`;
                if (tieStop) xml += '        <tie type="stop"/>\n';
                if (tieStart) xml += '        <tie type="start"/>\n';
                xml += `        <notations><technical><string>${sf.string}</string><fret>${sf.fret}</fret></technical>`;
                if (tieStop) xml += '<tied type="stop"/>';
                if (tieStart) xml += '<tied type="start"/>';
                xml += '</notations>\n';
                xml += '      </note>\n';
              });
            }
          }
          xml += '    </measure>\n';
        }
        xml += '  </part>\n';
        return xml;
      }

      let out = emitHeader() + '\n';
      for (const p of parts) out += emitPart(p);
      out += '</score-partwise>';
      return out;
    }

    // ====== KEYBOARD SHORTCUTS ======
    // Flag to track if text input is active
    let textInputActive = false;

    document.addEventListener('keydown', function (e) {
      const songModal = $('#songSearchModal');
      const isModalOpen = songModal && songModal.style.display !== 'none' && songModal.getAttribute('aria-hidden') === 'false';

      // Space bar handling
      if (e.key === ' ' || e.key === 'Spacebar') {
        if (isModalOpen || e.target.tagName === 'TEXTAREA' || e.target.id === 'songSearchInput' || textInputActive) {
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        const playBtn = $('#play');
        const pauseBtn = $('#pause');

        if (playBtn && pauseBtn) {
          if (AppState.isPlaying) {
            pauseBtn.click();
          } else {
            playBtn.click();
          }
        }
        return;
      }

      // Ignore other shortcuts when typing or when text input is active
      if (isModalOpen || e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA' || textInputActive) {
        return;
      }

      // Other shortcuts
      switch (e.key.toLowerCase()) {
        case 's':
          $('#stop')?.click();
          break;

        case 'a':
          const autoScrollEl = $('#autoScroll');
          if (autoScrollEl) {
            autoScrollEl.checked = !autoScrollEl.checked;
            autoScrollEl.dispatchEvent(new Event('change'));
          }
          break;

        case 'c':
          $('#countIn').click();
          break;

        case 'm':
          $('#metronome').click();
          break;

        case 'l':
          // Toggle loop
          const barAInput = $('#barA');
          const barBInput = $('#barB');
          const applyBtn = $('#applyLoop');
          const clearBtn = $('#clearAB');

          if (AppState.aBar && AppState.bBar) {
            clearBtn?.click();
            log('Loop: Cleared');
          } else {
            const totalBars = (at?.score?.masterBars) ? at.score.masterBars.length : 0;
            if (totalBars > 0) {
              const defaultA = '1';
              const defaultB = String(Math.min(8, Math.max(2, totalBars)));
              if (barAInput && barBInput && applyBtn) {
                barAInput.value = defaultA;
                barBInput.value = defaultB;
                applyBtn.click();
                log(`Loop: Set bars ${defaultA}-${defaultB}`);
              }
            }
          }
          break;

        case 't':
          const transposeEl = $('#transposeToggle');
          if (transposeEl) {
            transposeEl.checked = !transposeEl.checked;
            transposeEl.dispatchEvent(new Event('change'));
            log(`Transpose: ${transposeEl.checked ? 'ON' : 'OFF'}`);
          }
          break;
        case 'r':
          const recordBtn = $('#record');
          if (recordBtn) {
            recordBtn.click();
          }
          break;
        case 'arrowup':
          e.preventDefault();
          if (at) {
            const currentSpeed = at.playbackSpeed || 1;
            const newSpeed = Math.min(2.0, currentSpeed + 0.05);

            // Set speed only once
            at.playbackSpeed = newSpeed;

            // Update UI elements directly by triggering input event
            const speedSelect = $('#speed');
            if (speedSelect) {
              speedSelect.value = newSpeed;
              speedSelect.dispatchEvent(new Event('input', { bubbles: true }));
            }

            // Update BPM display directly
            const bpmBtn = $('#bpmBtn');
            if (bpmBtn && customMetronome.baseTempo) {
              const currentBPM = Math.round(customMetronome.baseTempo * newSpeed);
              bpmBtn.textContent = `BPM: ${currentBPM}`;
            }

            // Update metronome tempo without restart
            if (customMetronome.isPlaying) {
              customMetronome.tempo = customMetronome.baseTempo * newSpeed;
            }

            log(`Speed: ${Math.round(newSpeed * 100)}%`);
          }
          break;

        case 'arrowdown':
          e.preventDefault();
          if (at) {
            const currentSpeed = at.playbackSpeed || 1;
            const newSpeed = Math.max(0.25, currentSpeed - 0.05);

            // Set speed only once
            at.playbackSpeed = newSpeed;

            // Update UI elements directly by triggering input event
            const speedSelect = $('#speed');
            if (speedSelect) {
              speedSelect.value = newSpeed;
              speedSelect.dispatchEvent(new Event('input', { bubbles: true }));
            }

            // Update BPM display directly
            const bpmBtn = $('#bpmBtn');
            if (bpmBtn && customMetronome.baseTempo) {
              const currentBPM = Math.round(customMetronome.baseTempo * newSpeed);
              bpmBtn.textContent = `BPM: ${currentBPM}`;
            }

            // Update metronome tempo without restart
            if (customMetronome.isPlaying) {
              customMetronome.tempo = customMetronome.baseTempo * newSpeed;
            }

            log(`Speed: ${Math.round(newSpeed * 100)}%`);
          }
          break;
      }
    });

    // Prevent space from scrolling globally
    window.addEventListener('keydown', function (e) {
      if ((e.key === ' ' || e.key === 'Spacebar') &&
        e.target.tagName !== 'INPUT' &&
        e.target.tagName !== 'TEXTAREA') {
        e.preventDefault();
      }
    }, true);

    // ====== LOOP FUNCTIONALITY ======
    (function () {
      const alphaTabContainer = $('#alphaTab');
      const abSpan = $('#ab');
      const barAInput = $('#barA');
      const barBInput = $('#barB');
      const applyBtn = $('#applyLoop');
      const clearBtn = $('#clearAB');

      let loopMarkers = { start: null, end: null };

      function barCount() {
        try { return (at?.score?.masterBars) ? at.score.masterBars.length : 0; } catch (e) { return 0; }
      }

      function barDurationTicks(i) {
        try {
          const mb = at.score.masterBars[i];
          if (!mb) return 0;
          if (typeof mb.calculateDuration === 'function') return mb.calculateDuration();
          if (typeof mb.realDuration === 'number') return mb.realDuration;
          if (typeof mb.duration === 'number') return mb.duration;
          return 4 * 960;
        } catch (e) { return 0; }
      }

      function getBarStartTick(barNumber) {
        if (!at?.score?.masterBars) return null;
        const n = barCount();
        if (barNumber < 1 || barNumber > n) return null;
        let ticks = 0;
        for (let i = 0; i < barNumber - 1; i++) ticks += barDurationTicks(i);
        return ticks;
      }

      function getBarEndTick(barNumber) {
        if (!at?.score?.masterBars) return null;
        const n = barCount();
        if (barNumber < 1 || barNumber > n) return null;
        let ticks = 0;
        for (let i = 0; i < barNumber; i++) ticks += barDurationTicks(i);
        return ticks;
      }

      function removeLoopMarkers() {
        if (!alphaTabContainer) return;
        alphaTabContainer.querySelectorAll('.loop-marker').forEach(el => el.remove());
        loopMarkers.start = null;
        loopMarkers.end = null;
      }

      function createLoopMarker(barNumber, isStart) {
        const marker = document.createElement('div');
        marker.className = 'loop-marker ' + (isStart ? 'loop-start' : 'loop-end');
        const label = document.createElement('div');
        label.className = 'loop-label';
        label.textContent = (isStart ? 'A' : 'B') + ' (Bar ' + barNumber + ')';
        label.style.background = isStart ? '#4aa3ff' : '#7bd88f';
        marker.appendChild(label);
        return marker;
      }

      function barElementAtIndex(barIndex) {
        const candidates = ['[data-bar-index]', '.at-bar', '.at-cursor-bar', '[data-bar]'];
        for (const sel of candidates) {
          const list = alphaTabContainer.querySelectorAll(sel);
          if (list && list.length > barIndex) return list[barIndex];
        }
        const svgGroups = alphaTabContainer.querySelectorAll('g[data-bar-index], g.at-bar');
        if (svgGroups && svgGroups.length > barIndex) return svgGroups[barIndex];
        return null;
      }

      function positionMarker(marker, barNumber) {
        const barIdx = barNumber - 1;
        const el = barElementAtIndex(barIdx);
        if (!el) return;
        const rect = el.getBoundingClientRect();
        const contRect = alphaTabContainer.getBoundingClientRect();
        const x = (rect.left - contRect.left) + (alphaTabContainer.scrollLeft || 0);
        marker.style.left = Math.max(0, x - 1) + 'px';
        alphaTabContainer.appendChild(marker);
      }

      function updateABDisplay() {
        try {
          if (AppState.aBar && AppState.bBar) {
            AppState.aTick = getBarStartTick(AppState.aBar);
            AppState.bTick = getBarEndTick(AppState.bBar);

            if (AppState.aTick != null && AppState.bTick != null && AppState.bTick > AppState.aTick) {
              if (at?.player && typeof at.player.setPlaybackRange === 'function') {
                at.player.setPlaybackRange(AppState.aTick, AppState.bTick);
                at.player.isLooping = true;
              } else {
                at.playbackRange = { startTick: AppState.aTick, endTick: AppState.bTick };
                at.isLooping = true;
              }
              log(`Loop set: Bar ${AppState.aBar} (tick ${AppState.aTick}) to Bar ${AppState.bBar} (tick ${AppState.bTick})`);
            }
          } else {
            if (at?.player && typeof at.player.clearPlaybackRange === 'function') {
              at.player.clearPlaybackRange();
              at.player.isLooping = false;
            }
            if (at) {
              at.playbackRange = null;
              at.isLooping = false;
            }
            AppState.aTick = AppState.bTick = null;
          }
        } catch (e) { console.warn('Loop apply error', e); }
      }

      function applyBarLoop() {
        const newA = parseInt(barAInput?.value);
        const newB = parseInt(barBInput?.value);
        const maxBars = barCount();
        $('#alphaTab').classList.add('loop-active');

        if (!maxBars) { alert('Please load a score first.'); return; }
        if (!Number.isInteger(newA) || !Number.isInteger(newB)) { alert('Enter valid bar numbers.'); return; }
        if (newA < 1 || newB < 1 || newA > maxBars || newB > maxBars) { alert(`Bar numbers must be between 1 and ${maxBars}.`); return; }
        if (newA >= newB) { alert('Bar A must be before Bar B.'); return; }

        AppState.aBar = newA;
        AppState.bBar = newB;
        removeLoopMarkers();
        loopMarkers.start = createLoopMarker(AppState.aBar, true);
        loopMarkers.end = createLoopMarker(AppState.bBar, false);

        setTimeout(() => {
          positionMarker(loopMarkers.start, AppState.aBar);
          positionMarker(loopMarkers.end, AppState.bBar);
        }, 100);

        updateABDisplay();
      }

      function clearLoop() {
        AppState.aBar = AppState.bBar = AppState.aTick = AppState.bTick = null;
        $('#alphaTab').classList.remove('loop-active');
        removeLoopMarkers();
        updateABDisplay();
        if (barAInput) barAInput.value = '';
        if (barBInput) barBInput.value = '';
        log('Loop cleared');
      }

      if (applyBtn) applyBtn.addEventListener('click', applyBarLoop);
      if (clearBtn) clearBtn.addEventListener('click', clearLoop);

      function reflowMarkers() {
        if (loopMarkers.start && AppState.aBar) positionMarker(loopMarkers.start, AppState.aBar);
        if (loopMarkers.end && AppState.bBar) positionMarker(loopMarkers.end, AppState.bBar);
      }
      window.addEventListener('resize', reflowMarkers, { passive: true });
      if (alphaTabContainer) alphaTabContainer.addEventListener('scroll', reflowMarkers, { passive: true });

      try {
        if (at?.scoreLoaded && typeof at.scoreLoaded.on === 'function') {
          at.scoreLoaded.on((score) => {
            const totalBars = barCount();
            if (barAInput && barBInput) {
              barAInput.placeholder = '1';
              barBInput.placeholder = String(Math.min(8, Math.max(2, totalBars)));
            }
            clearLoop();
          });
        }
      } catch (e) { }
    })();

    // ====== RECORDING WITH COUNTDOWN ======
    (function () {
      let recStream = null, mediaRecorder = null, recChunks = [], prevMuteStates = null;
      let pendingBlob = null;
      let countdownInterval = null;
      let selectedInstrument = null; // Track selected instrument

      async function muteAllTracks() {
        try {
          const mutes = $$('.track .mute');
          prevMuteStates = mutes.map(btn => ({ btn, wasActive: btn.classList.contains('active') }));
          for (const { btn, wasActive } of prevMuteStates) {
            if (!wasActive) btn.click();
          }
        } catch (e) { }
      }

      function restoreMuteStates() {
        try {
          if (!prevMuteStates) return;
          for (const { btn, wasActive } of prevMuteStates) {
            const isActive = btn.classList.contains('active');
            if (isActive && !wasActive) btn.click();
          }
          prevMuteStates = null;
        } catch (e) { }
      }

      function showCountdown() {
        return new Promise((resolve, reject) => {
          const overlay = $('#recordCountdown');
          const numberEl = overlay.querySelector('.countdown-number');
          const textEl = overlay.querySelector('.countdown-text');
          const cancelBtn = overlay.querySelector('.countdown-cancel');

          overlay.style.display = 'flex';
          let count = 5;

          // Cancel handler
          const cancelCountdown = () => {
            if (countdownInterval) {
              clearInterval(countdownInterval);
              countdownInterval = null;
            }
            overlay.style.display = 'none';
            reject(new Error('Countdown cancelled'));
          };

          cancelBtn.onclick = cancelCountdown;

          // Countdown logic
          const updateCountdown = () => {
            if (count > 0) {
              numberEl.textContent = count;
              numberEl.className = 'countdown-number';
              textEl.textContent = 'Get Ready!';

              // Optional: Add audio beep for each count
              const beep = new AudioContext();
              const osc = beep.createOscillator();
              const gain = beep.createGain();
              osc.connect(gain);
              gain.connect(beep.destination);
              osc.frequency.value = count === 1 ? 880 : 660; // Higher pitch on last count
              gain.gain.value = 0.1;
              osc.start();
              osc.stop(beep.currentTime + 0.1);

              count--;
            } else if (count === 0) {
              numberEl.textContent = 'RECORDING!';
              numberEl.className = 'countdown-number recording';
              textEl.textContent = 'Session in progress';
              cancelBtn.style.display = 'none';
              count--;
            } else {
              clearInterval(countdownInterval);
              countdownInterval = null;
              overlay.style.display = 'none';
              resolve();
            }
          };

          updateCountdown(); // Show 5 immediately
          countdownInterval = setInterval(updateCountdown, 1000);
        });
      }

      async function startRecording(stream) {
        recChunks = [];
        recStream = stream; // Use the already granted stream
        mediaRecorder = new MediaRecorder(recStream);

        mediaRecorder.ondataavailable = e => {
          if (e.data.size > 0) recChunks.push(e.data);
        };

        mediaRecorder.onstop = () => {
          try {
            pendingBlob = new Blob(recChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
            showRecordingConfirmation();
          } catch (e) {
            console.error('Recording processing error:', e);
          }
        };

        await muteAllTracks();
        mediaRecorder.start();
        $('#play')?.click();
        log('🎤 Recording started');
      }

      function stopRecording() {
        try {
          if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
          }
          if (recStream) {
            recStream.getTracks().forEach(t => t.stop());
          }
        } catch (e) { }

        restoreMuteStates();
        $('#stop')?.click();
        log('⏹️ Recording stopped');
      }

      function downloadRecording() {
        if (!pendingBlob) return;

        try {
          const url = URL.createObjectURL(pendingBlob);
          const a = document.createElement('a');
          a.href = url;
          // Include instrument in filename if selected
          const instrument = selectedInstrument ? `_${selectedInstrument}` : '';
          a.download = `practice_recording${instrument}_${new Date().getTime()}.webm`;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 15000);
          pendingBlob = null;
          selectedInstrument = null; // Reset
          log(`📥 Recording downloaded successfully${instrument ? ` (${instrument})` : ''}`);
        } catch (e) {
          console.error('Download error:', e);
          alert('Failed to download recording');
        }
      }

      function showRecordingConfirmation() {
        const modal = $('#recordConfirmModal');
        if (modal) {
          modal.style.display = 'block';
          modal.setAttribute('aria-hidden', 'false');
        }
      }

      function hideRecordingConfirmation() {
        const modal = $('#recordConfirmModal');
        if (modal) {
          modal.style.display = 'none';
          modal.setAttribute('aria-hidden', 'true');
        }
      }

      function showInstrumentSelection() {
        const modal = $('#instrumentSelectModal');
        if (modal) {
          // Reset dropdown
          const select = $('#instrumentSelect');
          if (select) select.value = '';

          modal.style.display = 'block';
          modal.setAttribute('aria-hidden', 'false');
          hideRecordingConfirmation(); // Hide the first modal
        }
      }

      function hideInstrumentSelection() {
        const modal = $('#instrumentSelectModal');
        if (modal) {
          modal.style.display = 'none';
          modal.setAttribute('aria-hidden', 'true');
        }
      }

      // Main record button handler with countdown
      const recBtn = $('#record');
      const lamp = $('#recIndicator');

      if (recBtn) {
        recBtn.addEventListener('click', async () => {
          if (!AppState.isRecording) {
            let micStream = null;

            try {
              // STEP 1: Request microphone permission FIRST
              micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
              log('🎙️ Microphone access granted');

              // STEP 2: If permission granted, show countdown
              try {
                await showCountdown();

                // STEP 3: After countdown, start recording
                AppState.isRecording = true;
                recBtn.classList.add('rec-on');
                recBtn.textContent = '■ Stop';
                if (lamp) lamp.style.display = 'inline-flex';

                await startRecording(micStream);
              } catch (countdownError) {
                // User cancelled countdown
                if (micStream) {
                  micStream.getTracks().forEach(t => t.stop());
                }
                log('Countdown cancelled');
              }
            } catch (micError) {
              // Microphone permission denied
              alert('Microphone access is required to record. Please allow microphone access and try again.');
              log('❌ Microphone access denied');
            }
          } else {
            // Stop recording
            AppState.isRecording = false;
            recBtn.classList.remove('rec-on');
            recBtn.textContent = 'Record';
            if (lamp) lamp.style.display = 'none';
            stopRecording();
          }
        });
      }

      // Confirmation modal buttons - UPDATED
      $('#recordAIBtn')?.addEventListener('click', () => {
        showInstrumentSelection();
      });

      $('#recordAgainBtn')?.addEventListener('click', () => {
        pendingBlob = null;
        selectedInstrument = null;
        hideRecordingConfirmation();
        log('🔄 Recording discarded - ready to record again');
      });

      // Instrument selection modal handlers
    //   $('#instrumentConfirmBtn')?.addEventListener('click', () => {
    //     const select = $('#instrumentSelect');
    //     if (select && select.value) {
    //       selectedInstrument = select.value;
    //       log(`🎵 Instrument selected: ${selectedInstrument}`);
    //       hideInstrumentSelection();
    //       downloadRecording();
    //       log('🤖 AI Recommendation prepared for ' + selectedInstrument);
    //     } else {
    //       alert('Please select an instrument');
    //     }
    //   });


    // Updated instrument selection modal handler - calls your Next.js API
  // Updated instrument selection modal handler - uploads to Cloudinary first, then calls analysis API
$('#instrumentConfirmBtn')?.addEventListener('click', async () => {
  const select = $('#instrumentSelect');
  if (!select || !select.value) { 
    alert('Please select an instrument'); 
    return; 
  }
  selectedInstrument = select.value;
  log(`🎵 Instrument selected: ${selectedInstrument}`);

  if (!pendingBlob) { 
    hideInstrumentSelection(); 
    hideRecordingConfirmation(); 
    return; 
  }
  
  try {
    const up = document.getElementById('uploadLoading');
    if (up) up.style.display = 'flex';
    

    //  Hide upload loader, show analysis loader
  if (up) up.style.display = 'none';
  
  // Create and inject analysis loader
  const analysisLoader = document.createElement('div');
  analysisLoader.id = 'analysisLoader';
  analysisLoader.innerHTML = `
    <style>
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
    </style>
    <div style="text-align: center;">
      <div style="width: 60px; height: 60px; border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
      <p style="color: white; font-size: 18px; margin: 0;">Analyzing your performance...</p>
      <p style="color: #ccc; font-size: 14px; margin-top: 10px;">This may take a moment</p>
    </div>
  `;
  analysisLoader.style.cssText = 'display: flex; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 9999; justify-content: center; align-items: center; flex-direction: column;';
  document.body.appendChild(analysisLoader);

    // STEP 1: Upload audio to Cloudinary first
    log('📤 Uploading audio to Cloudinary...');
    const cloudinaryFormData = new FormData();
    cloudinaryFormData.append('audio', pendingBlob, 'practice_recording.webm');
    cloudinaryFormData.append('instrument', selectedInstrument);
    
    const cloudinaryResponse = await fetch('/Api/practice/upload', {
      method: 'POST',
      body: cloudinaryFormData
    });
    
    if (!cloudinaryResponse.ok) {
      const errorData = await cloudinaryResponse.json().catch(() => ({}));
      throw new Error(errorData.error || `Cloudinary upload failed: ${cloudinaryResponse.status}`);
    }
    
    const cloudinaryResult = await cloudinaryResponse.json();
    log('☁️ Audio uploaded to Cloudinary successfully');
    


    // STEP 2: Call analysis API with Cloudinary URL
    log('🔍 Starting AI analysis...');
    const analysisFormData = new FormData();
    analysisFormData.append('audio_file', pendingBlob, 'practice_recording.webm');
    analysisFormData.append('ratingPath', selectedInstrument);
    
    const analysisResponse = await fetch('/Api/proxy/practice', {
      method: 'POST',
      body: analysisFormData
    });
    
    if (!analysisResponse.ok) {
      // If analysis fails, clean up the Cloudinary file
      try {
        await fetch('/Api/practice/cleanup', {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ cloudinaryPublicId: cloudinaryResult.public_id })
        });
        log('🗑️ Cleaned up Cloudinary file due to analysis failure');
      } catch (cleanupError) {
        console.error('Failed to cleanup Cloudinary file:', cleanupError);
      }
      
      const errorData = await analysisResponse.json().catch(() => ({}));
      throw new Error(errorData.error || `Analysis failed: ${analysisResponse.status}`);
    }
    
    const analysisResult = await analysisResponse.json();
    log('✅ AI analysis completed successfully');
    
    // STEP 3: Store results with Cloudinary info in sessionStorage
    const analysisData = {
  ...analysisResult,
  instrument: selectedInstrument,
  timestamp: Date.now(),
  audioFile: {
    // Original file info
    url: cloudinaryResult.secure_url,
    publicId: cloudinaryResult.public_id,
    assetId: cloudinaryResult.asset_id,
    size: cloudinaryResult.bytes,
    type: 'audio/webm',
    
    // MP3 info (if available)
    mp3_url: cloudinaryResult.mp3_url,
    mp3_public_id: cloudinaryResult.mp3_public_id,
    has_mp3_version: cloudinaryResult.has_mp3_version,
    
    // Preferred URLs for playback and download
    playback_url: cloudinaryResult.playback_url,
    download_url: cloudinaryResult.download_url
  }
};
    
    sessionStorage.setItem('practiceAnalysisResults', JSON.stringify(analysisData));
    sessionStorage.setItem('practiceAnalysisInstrument', selectedInstrument);
    
    log('💾 Results stored in session storage with Cloudinary info');
    
    // Navigate to results page and preserve query parameters
const urlParams = new URLSearchParams(window.location.search);
const queryString = urlParams.toString();

if (queryString) {
  window.location.href = `/tutor/practiceResult?${queryString}`;
} else {
  window.location.href = '/tutor/practiceResult';
}
    
  } catch(err) {
    console.error('Process failed:', err);
    alert(`Process failed: ${err.message}`);
  }finally {
  const up = document.getElementById('uploadLoading');
  const analysisLoader = document.getElementById('analysisLoader');
  if (up) up.style.display = 'none';
  if (analysisLoader) analysisLoader.remove();
  hideInstrumentSelection();
  hideRecordingConfirmation();
  pendingBlob = null;
  selectedInstrument = null;
}
});
  $('#instrumentBackBtn')?.addEventListener('click', () => {
    hideInstrumentSelection();
    showRecordingConfirmation();
  });

    //   $('#instrumentBackBtn')?.addEventListener('click', () => {
    //     hideInstrumentSelection();
    //     showRecordingConfirmation(); // Go back to the first modal
    //   });

      // ESC key to close modals
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          const recordModal = $('#recordConfirmModal');
          const instrumentModal = $('#instrumentSelectModal');

          if (instrumentModal && instrumentModal.style.display !== 'none') {
            hideInstrumentSelection();
            showRecordingConfirmation();
          } else if (recordModal && recordModal.style.display !== 'none') {
            hideRecordingConfirmation();
            pendingBlob = null;
            selectedInstrument = null;
          }
        }
      });
    })();

    // ====== PIANO KEYBOARD ======
    (function () {
      const A0 = 21, C8 = 108;
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

      function isBlack(pc) { return (pc === 1 || pc === 3 || pc === 6 || pc === 8 || pc === 10); }
      function whiteHasBlackAfter(pc) { return (pc === 0 || pc === 2 || pc === 5 || pc === 7 || pc === 9); }

      function midiToName(m) {
        const pc = m % 12;
        const oct = Math.floor(m / 12) - 1;
        return noteNames[pc] + oct;
      }

      function buildKeyboard(root) {
        const keysWrap = document.createElement('div');
        keysWrap.className = 'keys';
        const whites = document.createElement('div');
        whites.className = 'white-keys';
        const blacks = document.createElement('div');
        blacks.className = 'black-keys';

        const keyMap = new Map();

        let midi = A0;
        while (midi <= C8) {
          const whiteKey = document.createElement('div');
          whiteKey.className = 'white-key';
          whites.appendChild(whiteKey);
          keyMap.set(midi, whiteKey);

          const pc = midi % 12;
          const lbl = document.createElement('div');
          lbl.className = 'label';
          lbl.textContent = (pc === 0 ? midiToName(midi) : noteNames[pc]);
          whiteKey.appendChild(lbl);

          const next = midi + 1;
          if (whiteHasBlackAfter(pc) && next <= C8) {
            const wrap = document.createElement('div');
            wrap.className = 'black-key-wrap';
            const black = document.createElement('div');
            black.className = 'black-key';
            const bl = document.createElement('div');
            bl.className = 'label';
            bl.textContent = midiToName(next);
            black.appendChild(bl);
            wrap.appendChild(black);
            blacks.appendChild(wrap);
            keyMap.set(next, black);
            midi = next + 1;
          } else {
            const spacer = document.createElement('div');
            spacer.className = 'black-key-wrap';
            blacks.appendChild(spacer);
            midi = midi + 1;
          }
        }

        keysWrap.appendChild(whites);
        keysWrap.appendChild(blacks);
        root.appendChild(keysWrap);
        return keyMap;
      }

      function makePresser(keyMap) {
        const timers = new Map();
        return function press(midi, hand) {
          const el = keyMap.get(midi);
          if (!el) return;
          el.classList.add('pressed');
          if (hand === 'R') el.classList.add('pressed-right');
          else if (hand === 'L') el.classList.add('pressed-left');

          if (timers.has(midi)) clearTimeout(timers.get(midi));
          timers.set(midi, setTimeout(() => {
            el.classList.remove('pressed', 'pressed-right', 'pressed-left');
            timers.delete(midi);
          }, 240));
        };
      }

      const container = $('#pianoContainer');
      if (!container) return;
      const keyMap = buildKeyboard(container);
      const pressKey = makePresser(keyMap);

      const keyboardBtn = $('#toggleKeyboard');
      let keyboardOn = false;
      function setKeyboard(v) {
        keyboardOn = !!v;
        container.classList.toggle('hidden', !keyboardOn);
        container.setAttribute('aria-hidden', String(!keyboardOn));
        if (keyboardBtn) {
          keyboardBtn.textContent = 'Keyboard';  // Changed from 'Keyboard: ' + (keyboardOn ? 'On' : 'Off')
          keyboardBtn.classList.toggle('active', keyboardOn);  // Add active class toggle
        }
      }
      keyboardBtn?.addEventListener('click', () => setKeyboard(!keyboardOn));
      setKeyboard(false);

      function inferHand(midi, evElement) {
        try {
          const s = evElement?.beat?.voice?.staff || evElement?.voice?.staff || evElement?.staff || null;
          if (s && typeof s.index === 'number') {
            if (s.index === 0) return 'R';
            if (s.index === 1) return 'L';
          }
        } catch { /* ignore */ }
        return (typeof midi === 'number' && midi >= 60) ? 'R' : 'L';
      }

      function isKeyboardyTrack(idx) {
        if (!at?.score || idx == null) return false;
        const t = at.score.tracks[idx];
        if (!t || t.isPercussion) return false;
        const n = (t.name || '').toLowerCase();
        return /piano|synth|keys|keyboard|organ|rhodes|bass/.test(n);
      }

      try {
        if (at) {
          at.midiEventsPlayedFilter = [alphaTab.midi.MidiEventType.NoteOn];
          at.midiEventsPlayed.on(e => {
            if (!keyboardOn) return;
            const arr = e?.events || [];
            for (const me of arr) {
              let idx = null;
              try {
                const t = me?.element?.beat?.voice?.track || me?.element?.voice?.track || me?.element?.staff?.track || me?.element?.track || null;
                if (t && at.score) idx = at.score.tracks.indexOf(t);
              } catch { /* ignore */ }
              if (idx != null && !isKeyboardyTrack(idx)) continue;
              const midi = (me?.param1 ?? me?.data1 ?? me?.note ?? null);
              if (typeof midi !== 'number') continue;
              const hand = inferHand(midi, me?.element);
              pressKey(midi, hand);
            }
          });
        }
      } catch (err) { console.warn('Keyboard hook failed', err); }
    })();

    // ====== PDF VIEWER ======
    (function () {
      const atContainer = () => $('#alphaTab');
      const metaBox = () => $('#meta');

      const pdfState = { pdf: null, zoom: 1.0, baseScale: 1.0 };

      function ensurePdfOverlay() {
        const host = atContainer();
        if (!host) return null;
        host.classList.add('pdf-mode');
        try {
          const wrap = host.closest('.wrap');
          if (wrap) wrap.classList.add('pdf-active');
        } catch (_) { }

        let overlay = host.querySelector('.pdf-overlay');
        if (!overlay) {
          overlay = document.createElement('div');
          overlay.className = 'pdf-overlay';
          overlay.innerHTML = [
            '<div class="pdf-toolbar">',
            '<button class="btn" id="pdfZoomOut">−</button>',
            '<button class="btn" id="pdfZoomIn">+</button>',
            '<button class="btn" id="pdfFit">Fit Width</button>',
            '<button class="btn" id="pdfScrollToggle" aria-pressed="false" title="Auto-scroll the PDF">Scroll ▶</button>',
            '<select id="pdfScrollSpeed" class="pdf-select" aria-label="Scroll speed">',
            '<option value="30">30 px/s</option>',
            '<option value="40">40 px/s</option>',
            '<option value="50" selected>50 px/s</option>',
            '<option value="60">60 px/s</option>',
            '<option value="70">70 px/s</option>',
            '<option value="80">80 px/s</option>',
            '<option value="90">90 px/s</option>',
            '<option value="100">100 px/s</option>',
            '</select>',

            /* Annotation Controls - Enhanced */
            '<div class="pdf-annotation-controls">',
            /* Drawing Tools Row */
            '<button class="pdf-annotation-btn" id="pdfDrawTool" title="Draw on PDF">Draw</button>',
            '<button class="pdf-annotation-btn" id="pdfHighlightTool" title="Highlight text">Highlight</button>',
            '<button class="pdf-annotation-btn" id="pdfFillTool" title="Fill shapes with color">Fill</button>',
            '<button class="pdf-annotation-btn" id="pdfEraserTool" title="Erase annotations">Eraser</button>',

            /* Shapes Dropdown */
            '<div class="pdf-shapes-dropdown-wrapper">',
            '<button class="pdf-annotation-btn" id="pdfShapesBtn" title="Draw shapes">Shapes ▼</button>',
            '<div id="pdfShapesDropdown" class="pdf-shapes-dropdown" style="display:none; grid-template-columns: repeat(4, 1fr); gap: 4px; padding: 6px;">',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfArrowTool" title="Arrow" style="padding: 6px; font-size: 16px;">➜</button>',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfCircleTool" title="Circle" style="padding: 6px; font-size: 16px;">⭕</button>',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfRectangleTool" title="Rectangle" style="padding: 6px; font-size: 16px;">⬜</button>',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfLineTool" title="Line" style="padding: 6px; font-size: 16px;">📏</button>',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfStarTool" title="Star" style="padding: 6px; font-size: 16px;">⭐</button>',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfQuarterNoteTool" title="Quarter Note" style="padding: 6px; font-size: 16px;">♩</button>',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfEighthNoteTool" title="Eighth Note" style="padding: 6px; font-size: 16px;">♪</button>',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfBeamedEighthTool" title="Beamed Eighth" style="padding: 6px; font-size: 16px;">♫</button>',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfBeamedSixteenthTool" title="Beamed Sixteenth" style="padding: 6px; font-size: 16px;">♬</button>',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfFlatTool" title="Flat" style="padding: 6px; font-size: 16px;">♭</button>',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfNaturalTool" title="Natural" style="padding: 6px; font-size: 16px;">♮</button>',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfSharpTool" title="Sharp" style="padding: 6px; font-size: 16px;">♯</button>',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfTrebleClefTool" title="Treble Clef" style="padding: 6px; font-size: 16px;">𝄞</button>',
            '<button class="pdf-annotation-btn pdf-shape-item" id="pdfBassClefTool" title="Bass Clef" style="padding: 6px; font-size: 16px;">𝄢</button>',
            '</div>',
            '</div>',

            /* Separator */
            '<span class="pdf-separator"></span>',

            /* Color and Size Controls */
            '<label class="pdf-control-label">Color:</label>',
            '<input type="color" id="pdfAnnotationColor" class="pdf-color-picker" value="#FFFF00" title="Annotation color">',
            '<label class="pdf-control-label">Size:</label>',
            '<input type="number" id="pdfAnnotationSize" class="pdf-size-input" value="3" min="1" max="20" title="Brush size">',
            '<span id="pdfSizeDisplay" class="pdf-size-display">3</span>',

            /* Separator */
            '<span class="pdf-separator"></span>',

            /* Action Buttons */
            '<button class="pdf-annotation-btn" id="pdfUndoAnnotations" title="Undo last action">↶ Undo</button>',
            '<button class="pdf-annotation-btn" id="pdfRedoAnnotations" title="Redo last undone action" disabled style="opacity: 0.5;">↷ Redo</button>',
            '<button class="pdf-annotation-btn" id="pdfClearAnnotations" title="Clear all annotations">Clear</button>',
            '<button class="pdf-annotation-btn pdf-save-btn" id="pdfSaveAnnotations" title="Save annotations">Save</button>',
            '</div>',
            '</div>',
            '<div id="pdfContainer" class="pdf-container"></div>'
          ].join('');
          host.appendChild(overlay);
        }
        return { host, overlay, container: overlay.querySelector('#pdfContainer') };
      }

      async function renderAllPages() {
        if (!pdfState.pdf) return;
        const host = atContainer();
        const container = host?.querySelector('#pdfContainer');
        if (!container || !host) return;

        container.innerHTML = '';

        const tempPage = await pdfState.pdf.getPage(1);
        const viewport1 = tempPage.getViewport({ scale: 1 });
        const usable = Math.max(320, host.clientWidth - 24);
        pdfState.baseScale = usable / viewport1.width;

        const scale = pdfState.baseScale * pdfState.zoom;
        const total = pdfState.pdf.numPages;

        for (let p = 1; p <= total; p++) {
          const page = await pdfState.pdf.getPage(p);
          const viewport = page.getViewport({ scale });
          const wrap = document.createElement('div');
          wrap.className = 'pdf-page';
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          canvas.width = Math.floor(viewport.width);
          canvas.height = Math.floor(viewport.height);
          wrap.appendChild(canvas);
          container.appendChild(wrap);
          await page.render({ canvasContext: ctx, viewport }).promise;
        }
      }

      function attachToolbarHandlers() {
        const host = atContainer();
        const overlay = host?.querySelector('.pdf-overlay');
        const container = host?.querySelector('#pdfContainer');
        const prev = $('#pdfPrev'), next = $('#pdfNext'), zi = $('#pdfZoomIn'), zo = $('#pdfZoomOut'), fit = $('#pdfFit');
        const scrollBtn = $('#pdfScrollToggle');
        const speedSel = $('#pdfScrollSpeed');

        if (zi) zi.addEventListener('click', async () => { pdfState.zoom = Math.min(3, pdfState.zoom + 0.1); await renderAllPages(); const pdfContainer = document.querySelector('#pdfContainer'); if (pdfContainer) { initPdfAnnotations(pdfContainer); } });
        if (zo) zo.addEventListener('click', async () => { pdfState.zoom = Math.max(0.3, pdfState.zoom - 0.1); await renderAllPages(); const pdfContainer = document.querySelector('#pdfContainer'); if (pdfContainer) { initPdfAnnotations(pdfContainer); } });
        if (fit) fit.addEventListener('click', async () => { pdfState.zoom = 1.0; await renderAllPages(); const pdfContainer = document.querySelector('#pdfContainer'); if (pdfContainer) { initPdfAnnotations(pdfContainer); } });

        let _scrollReq = null, _lastTs = 0;
        function stopPdfScroll() {
          if (_scrollReq) { cancelAnimationFrame(_scrollReq); _scrollReq = null; }
          _lastTs = 0;
          if (customMetronome.isPlaying) {
            customMetronome.stop();
          }
          if (scrollBtn) { scrollBtn.textContent = 'Scroll ▶'; scrollBtn.setAttribute('aria-pressed', 'false'); }
        }
        function startPdfScroll() {
          if (!overlay || !host) return; // Added host check
          const speed = Math.max(5, parseFloat(speedSel?.value || '50'));
          stopPdfScroll();
          function step(ts) {
            if (!_lastTs) _lastTs = ts;
            const dt = (ts - _lastTs) / 1000;
            _lastTs = ts;
            host.scrollTop += speed * dt;
            const maxY = host.scrollHeight - host.clientHeight - 1;
            if (host.scrollTop >= maxY) { stopPdfScroll(); return; }
            _scrollReq = requestAnimationFrame(step);
          }
          if (metronomeSettings.enabled && !customMetronome.isPlaying) {
            customMetronome.setVolume(metronomeSettings.volume);
            customMetronome.setSubdivision(metronomeSettings.subdivision);
            customMetronome.start();
          }
          _scrollReq = requestAnimationFrame(step);
          if (scrollBtn) { scrollBtn.textContent = 'Scroll ⏸'; scrollBtn.setAttribute('aria-pressed', 'true'); }
        }

        if (scrollBtn) {
          scrollBtn.addEventListener('click', () => {
            if (_scrollReq) stopPdfScroll(); else startPdfScroll();
          });
        }

        if (speedSel) {
          speedSel.addEventListener('change', () => {
            if (_scrollReq) { startPdfScroll(); }
          });
        }

        function scrollStep(dir) {
          if (!container) return; // Safety check in case container is null
          const pages = Array.from(container.querySelectorAll('canvas'));
          const y = host ? host.scrollTop : 0;
          let idx = pages.findIndex(c => c.offsetTop + c.height > y + 10);
          if (idx < 0) idx = 0;
          pages[Math.max(0, Math.min(pages.length - 1, idx + dir))].scrollIntoView({ behavior: 'smooth' });
        }
        if (prev) prev.addEventListener('click', () => { stopPdfScroll(); scrollStep(-1); });
        if (next) next.addEventListener('click', () => { stopPdfScroll(); scrollStep(+1); });
      }

      // PDF Annotation System
      let pdfAnnotationState = {
        isDrawing: false,
        currentTool: null,
        color: '#FFFF00',
        size: 3,
        annotationCanvas: null,
        annotationCtx: null,
        startX: 0,
        startY: 0,
        canvases: [],
        history: [],
        redoHistory: [],
        textFont: 'Arial',
        textSize: 16,
        textBold: false,
        textItalic: false
      };

      function initPdfAnnotations(container) {
        if (!container) return;

        // CLEANUP: Remove old annotation layers before creating new ones
        const oldAnnotationLayers = container.querySelectorAll('.pdf-annotation-layer');
        oldAnnotationLayers.forEach(layer => {
          layer.removeEventListener('mousedown', null);
          layer.removeEventListener('mousemove', null);
          layer.removeEventListener('mouseup', null);
          layer.removeEventListener('mouseleave', null);
          layer.remove();
        });

        // Reset the annotation state
        pdfAnnotationState.currentTool = null;
        pdfAnnotationState.canvases = [];
        pdfAnnotationState.isDrawing = false;
        pdfAnnotationState.annotationCanvas = null;
        pdfAnnotationState.history = [];
        pdfAnnotationState.historyIndex = -1;

        // Get all PDF page canvases
        pdfAnnotationState.canvases = Array.from(container.querySelectorAll('.pdf-page canvas'));

        // Setup annotation layer for each canvas
        pdfAnnotationState.canvases.forEach((canvas, idx) => {
          const wrapper = canvas.parentElement;
          const annotCanvas = document.createElement('canvas');
          annotCanvas.className = 'pdf-annotation-layer';
          annotCanvas.width = canvas.width;
          annotCanvas.height = canvas.height;
          annotCanvas.style.position = 'absolute';
          annotCanvas.style.cursor = 'crosshair';
          annotCanvas.style.display = 'block';

          if (wrapper && wrapper.style.position !== 'absolute' && wrapper.style.position !== 'relative') {
            wrapper.style.position = 'relative';
          }
          wrapper.insertBefore(annotCanvas, canvas.nextSibling);

          // Add mouse events
          annotCanvas.addEventListener('mousedown', (e) => startDrawing(e, annotCanvas));
          annotCanvas.addEventListener('mousemove', (e) => draw(e, annotCanvas));
          annotCanvas.addEventListener('mouseup', (e) => {
            const tool = pdfAnnotationState.currentTool;
            if (['rectangle', 'circle', 'arrow', 'line', 'star', 'quarterNote', 'eighthNote', 'beamedEighth', 'beamedSixteenth', 'flat', 'natural', 'sharp', 'trebleClef', 'bassClef'].includes(tool)) {
              stopDrawingWithShape(e, annotCanvas);
            } else if (tool === 'draw' || tool === 'eraser') {
              savePdfAnnotationState();
              stopDrawing();
            } else {
              stopDrawing();
            }
          });
          annotCanvas.addEventListener('mouseleave', () => stopDrawing());
          annotCanvas.addEventListener('contextmenu', (e) => e.preventDefault());

          // Add touch event listeners for mobile support
          annotCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
              clientX: touch.clientX,
              clientY: touch.clientY
            });
            annotCanvas.dispatchEvent(mouseEvent);
          });

          annotCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
              clientX: touch.clientX,
              clientY: touch.clientY
            });
            annotCanvas.dispatchEvent(mouseEvent);
          });

          annotCanvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            const mouseEvent = new MouseEvent('mouseup', {
              clientX: touch.clientX,
              clientY: touch.clientY
            });
            annotCanvas.dispatchEvent(mouseEvent);
          });

          annotCanvas.addEventListener('touchcancel', (e) => {
            pdfAnnotationState.isDrawing = false;
          });
        });

        pdfAnnotationState.history = [];
        pdfAnnotationState.historyIndex = -1;

        // Attach button handlers
        const drawBtn = $('#pdfDrawTool');
        const highlightBtn = $('#pdfHighlightTool');
        const colorPicker = $('#pdfAnnotationColor');
        const sizePicker = $('#pdfAnnotationSize');
        const clearBtn = $('#pdfClearAnnotations');
        const saveBtn = $('#pdfSaveAnnotations');

        // Initialize history with empty state (so undo/redo works correctly)
        if (pdfAnnotationState.history.length === 0) {
          pdfAnnotationState.canvases = Array.from(container.querySelectorAll('.pdf-page canvas'));
          if (pdfAnnotationState.canvases.length > 0) {
            pdfAnnotationState.history.push(
              pdfAnnotationState.canvases.map(canvas => {
                const wrapper = canvas.parentElement;
                const annotCanvas = wrapper?.querySelector('.pdf-annotation-layer');
                return annotCanvas ? annotCanvas.toDataURL() : canvas.toDataURL();
              })
            );
          }
        }

        if (drawBtn) {
          drawBtn.addEventListener('click', () => {
            pdfAnnotationState.currentTool = pdfAnnotationState.currentTool === 'draw' ? null : 'draw';
            drawBtn.classList.toggle('active');
            document.querySelectorAll('.pdf-annotation-btn').forEach(btn => {
              if (btn !== drawBtn) btn.classList.remove('active');
            });
          });
        }

        if (highlightBtn) {
          highlightBtn.addEventListener('click', () => {
            pdfAnnotationState.currentTool = pdfAnnotationState.currentTool === 'highlight' ? null : 'highlight';
            highlightBtn.classList.toggle('active');
            document.querySelectorAll('.pdf-annotation-btn').forEach(btn => {
              if (btn !== highlightBtn) btn.classList.remove('active');
            });
          });
        }

        if (colorPicker) {
          colorPicker.addEventListener('change', (e) => {
            pdfAnnotationState.color = e.target.value;
          });
        }

        if (sizePicker) {
          sizePicker.addEventListener('change', (e) => {
            pdfAnnotationState.size = Math.max(1, Math.min(20, parseInt(e.target.value)));
            e.target.value = pdfAnnotationState.size;
            document.getElementById('pdfSizeDisplay').textContent = pdfAnnotationState.size;
          });
          sizePicker.addEventListener('input', (e) => {
            pdfAnnotationState.size = Math.max(1, Math.min(20, parseInt(e.target.value)));
            document.getElementById('pdfSizeDisplay').textContent = pdfAnnotationState.size;
          });
        }

        // Eraser Tool
        const eraserBtn = $('#pdfEraserTool');
        if (eraserBtn) {
          eraserBtn.addEventListener('click', () => {
            pdfAnnotationState.currentTool = pdfAnnotationState.currentTool === 'eraser' ? null : 'eraser';
            eraserBtn.classList.toggle('active');
            document.querySelectorAll('.pdf-annotation-btn').forEach(btn => {
              if (btn !== eraserBtn) btn.classList.remove('active');
            });
          });
        }

        // Fill Tool
        const fillBtn = $('#pdfFillTool');
        if (fillBtn) {
          fillBtn.addEventListener('click', () => {
            pdfAnnotationState.currentTool = pdfAnnotationState.currentTool === 'fill' ? null : 'fill';
            fillBtn.classList.toggle('active');
            document.querySelectorAll('.pdf-annotation-btn').forEach(btn => {
              if (btn !== fillBtn) btn.classList.remove('active');
            });
          });
        }

        // Shapes Dropdown
        const shapesBtn = $('#pdfShapesBtn');
        const shapesDropdown = $('#pdfShapesDropdown');
        if (shapesBtn && shapesDropdown) {
          shapesBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isVisible = shapesDropdown.style.display !== 'none';
            shapesDropdown.style.display = isVisible ? 'none' : 'block';
            // Toggle active class on the button
            if (isVisible) {
              shapesBtn.classList.remove('active');
            } else {
              shapesBtn.classList.add('active');
              // Remove active class from draw, highlight, eraser buttons
              document.querySelectorAll('.pdf-annotation-btn').forEach(btn => {
                if (btn !== shapesBtn) btn.classList.remove('active');
              });
            }
          });

          // Close dropdown when selecting a shape
          shapesDropdown.addEventListener('click', () => {
            setTimeout(() => {
              shapesDropdown.style.display = 'none';
              shapesBtn.classList.add('active');
            }, 50);
          });

          // Shape buttons
          ['arrow', 'circle', 'rectangle', 'line', 'star', 'quarterNote', 'eighthNote', 'beamedEighth', 'beamedSixteenth', 'flat', 'natural', 'sharp', 'trebleClef', 'bassClef'].forEach(shape => {
            const btn = $(`#pdf${shape.charAt(0).toUpperCase() + shape.slice(1)}Tool`);
            if (btn) {
              btn.addEventListener('click', () => {
                pdfAnnotationState.currentTool = shape;
                shapesDropdown.style.display = 'none';
                shapesBtn.classList.add('active');
                // Remove active class from all other tool buttons
                document.querySelectorAll('.pdf-annotation-btn').forEach(b => {
                  if (b !== shapesBtn) b.classList.remove('active');
                });
              });
            }
          });
        }

        // Undo/Redo
        const undoBtn = $('#pdfUndoAnnotations');
        const redoBtn = $('#pdfRedoAnnotations');

        if (undoBtn) {
          undoBtn.addEventListener('click', () => {
            // Only undo if there are states to undo (more than just the initial empty state)
            if (pdfAnnotationState.history.length > 1) {
              pdfAnnotationState.redoHistory.push(pdfAnnotationState.history.pop());
              if (pdfAnnotationState.history.length > 0) {
                // Restore the previous state
                restorePdfAnnotationState(pdfAnnotationState.history[pdfAnnotationState.history.length - 1]);
              } else {
                // Last annotation was undone - clear canvas but DON'T clear redoHistory!
                pdfAnnotationState.canvases.forEach(canvas => {
                  const wrapper = canvas.parentElement;
                  const annotCanvas = wrapper?.querySelector('.pdf-annotation-layer');
                  if (annotCanvas) {
                    const ctx = annotCanvas.getContext('2d');
                    ctx.clearRect(0, 0, annotCanvas.width, annotCanvas.height);
                  }
                });
              }
              // Update both undo and redo button states
              updatePdfUndoButtonState();
              updatePdfRedoButtonState();
            }
          });
        }

        if (redoBtn) {
          redoBtn.addEventListener('click', () => {
            if (pdfAnnotationState.redoHistory.length > 0) {
              pdfAnnotationState.history.push(pdfAnnotationState.redoHistory.pop());
              restorePdfAnnotationState(pdfAnnotationState.history[pdfAnnotationState.history.length - 1]);
              // Update both undo and redo button states
              updatePdfUndoButtonState();
              updatePdfRedoButtonState();
            }
          });
        }

        // Initialize button states when PDF annotation handlers are set up
        updatePdfUndoButtonState();
        updatePdfRedoButtonState();

        if (clearBtn) {
          clearBtn.addEventListener('click', () => {
            clearAllPdfAnnotations(true);
            // Reset button states when annotations are cleared
            updatePdfUndoButtonState();
            updatePdfRedoButtonState();
            log('PDF annotations cleared');
          });
        }

        if (saveBtn) {
          saveBtn.addEventListener('click', () => {
            savePdfAnnotations();
          });
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', (e) => {
          const shapesDropdown = document.getElementById('pdfShapesDropdown');
          const shapesBtn = document.getElementById('pdfShapesBtn');

          if (shapesDropdown && !e.target.closest('.pdf-shapes-dropdown-wrapper')) {
            shapesDropdown.style.display = 'none';
            if (shapesBtn && !pdfAnnotationState.currentTool?.includes('shape')) {
              shapesBtn.classList.remove('active');
            }
          }
        });
      }

      function startDrawing(e, canvas) {
        if (!pdfAnnotationState.currentTool) return;

        pdfAnnotationState.isDrawing = true;
        const rect = canvas.getBoundingClientRect();
        pdfAnnotationState.startX = e.clientX - rect.left;
        pdfAnnotationState.startY = e.clientY - rect.top;
        pdfAnnotationState.annotationCanvas = canvas;
        pdfAnnotationState.annotationCtx = canvas.getContext('2d');

        // Handle fill tool - execute immediately on click
        if (pdfAnnotationState.currentTool === 'fill') {
          floodFillPdf(canvas, pdfAnnotationState.startX, pdfAnnotationState.startY, pdfAnnotationState.color);
          savePdfAnnotationState();
          pdfAnnotationState.isDrawing = false;
          return;
        }

        // Save canvas state for shape preview (so we can restore and redraw preview)
        pdfAnnotationState.canvasSnapshot = canvas.toDataURL();

        // Save state for undo on shape tools
        if (['rectangle', 'circle', 'arrow', 'line', 'star', 'quarterNote', 'eighthNote', 'beamedEighth', 'beamedSixteenth', 'flat', 'natural', 'sharp', 'trebleClef', 'bassClef'].includes(pdfAnnotationState.currentTool)) {
          savePdfAnnotationState();
        }
      }

      function draw(e, canvas) {
        if (!pdfAnnotationState.isDrawing || !pdfAnnotationState.currentTool) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const ctx = canvas.getContext('2d');

        if (pdfAnnotationState.currentTool === 'draw') {
          ctx.strokeStyle = pdfAnnotationState.color;
          ctx.lineWidth = pdfAnnotationState.size;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          ctx.beginPath();
          ctx.moveTo(pdfAnnotationState.startX, pdfAnnotationState.startY);
          ctx.lineTo(x, y);
          ctx.stroke();
          pdfAnnotationState.startX = x;
          pdfAnnotationState.startY = y;
        } else if (pdfAnnotationState.currentTool === 'eraser') {
          const eraserSize = pdfAnnotationState.size * 3;
          ctx.clearRect(x - eraserSize / 2, y - eraserSize / 2, eraserSize, eraserSize);
          pdfAnnotationState.startX = x;
          pdfAnnotationState.startY = y;
        } else if (pdfAnnotationState.currentTool === 'highlight') {
          // Highlight preview - restore canvas and draw preview (like shapes)
          if (pdfAnnotationState.canvasSnapshot) {
            const img = new Image();
            img.onload = function () {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img, 0, 0);

              // Draw highlight preview with transparency
              const highlightColor = hexToRgba(pdfAnnotationState.color, 0.5);
              ctx.fillStyle = highlightColor;
              ctx.fillRect(
                Math.min(pdfAnnotationState.startX, x),
                Math.min(pdfAnnotationState.startY, y),
                Math.abs(x - pdfAnnotationState.startX),
                Math.abs(y - pdfAnnotationState.startY)
              );
            };
            img.src = pdfAnnotationState.canvasSnapshot;
          }
        } else {
          // Shape preview - restore canvas and draw preview
          if (pdfAnnotationState.canvasSnapshot) {
            const img = new Image();
            img.onload = function () {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(img, 0, 0);

              // Draw preview of shape being created
              ctx.strokeStyle = pdfAnnotationState.color;
              ctx.fillStyle = pdfAnnotationState.color;
              ctx.lineWidth = pdfAnnotationState.size;
              ctx.lineCap = 'round';
              ctx.lineJoin = 'round';
              ctx.globalAlpha = 0.6; // Preview with transparency

              const tool = pdfAnnotationState.currentTool;
              if (tool === 'rectangle') {
                ctx.strokeRect(
                  Math.min(pdfAnnotationState.startX, x),
                  Math.min(pdfAnnotationState.startY, y),
                  Math.abs(x - pdfAnnotationState.startX),
                  Math.abs(y - pdfAnnotationState.startY)
                );
              } else if (tool === 'circle') {
                const radius = Math.sqrt(Math.pow(x - pdfAnnotationState.startX, 2) + Math.pow(y - pdfAnnotationState.startY, 2));
                ctx.beginPath();
                ctx.arc(pdfAnnotationState.startX, pdfAnnotationState.startY, radius, 0, 2 * Math.PI);
                ctx.stroke();
              } else if (tool === 'line') {
                ctx.beginPath();
                ctx.moveTo(pdfAnnotationState.startX, pdfAnnotationState.startY);
                ctx.lineTo(x, y);
                ctx.stroke();
              } else if (tool === 'arrow') {
                drawArrowPdf(ctx, pdfAnnotationState.startX, pdfAnnotationState.startY, x, y);
              } else if (tool === 'star') {
                drawStarPdf(ctx, (pdfAnnotationState.startX + x) / 2, (pdfAnnotationState.startY + y) / 2, Math.abs(x - pdfAnnotationState.startX) / 2);
              } else if (['quarterNote', 'eighthNote', 'beamedEighth', 'beamedSixteenth', 'flat', 'natural', 'sharp', 'trebleClef', 'bassClef'].includes(tool)) {
                // Music symbol preview with size based on drag distance
                const distance = Math.sqrt(Math.pow(x - pdfAnnotationState.startX, 2) + Math.pow(y - pdfAnnotationState.startY, 2));
                const size = Math.max(20, Math.min(distance * 2, 150)); // Scale between 20px and 150px

                let symbol = '';
                if (tool === 'quarterNote') symbol = '♩';
                else if (tool === 'eighthNote') symbol = '♪';
                else if (tool === 'beamedEighth') symbol = '♫';
                else if (tool === 'beamedSixteenth') symbol = '♬';
                else if (tool === 'flat') symbol = '♭';
                else if (tool === 'natural') symbol = '♮';
                else if (tool === 'sharp') symbol = '♯';
                else if (tool === 'trebleClef') symbol = '𝄞';
                else if (tool === 'bassClef') symbol = '𝄢';

                drawMusicSymbolPdf(ctx, pdfAnnotationState.startX, pdfAnnotationState.startY, symbol, size);
              }

              ctx.globalAlpha = 1.0; // Reset transparency
            };
            img.src = pdfAnnotationState.canvasSnapshot;
          }
        }
      }

      function hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      function stopDrawing() {
        if (!pdfAnnotationState.isDrawing || !pdfAnnotationState.currentTool) return;

        const canvas = pdfAnnotationState.annotationCanvas;
        const ctx = pdfAnnotationState.annotationCtx;
        if (!canvas || !ctx) {
          pdfAnnotationState.isDrawing = false;
          return;
        }

        const x = pdfAnnotationState.startX;
        const y = pdfAnnotationState.startY;

        // Get current mouse position (need to calculate from last position)
        // For shapes drawn on mouse up, we handle them in the mouse up event

        pdfAnnotationState.isDrawing = false;
      }

      // Enhanced stopDrawing with shape rendering
      function stopDrawingWithShape(e, canvas) {
        if (!pdfAnnotationState.isDrawing || !pdfAnnotationState.currentTool) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        const ctx = canvas.getContext('2d');
        const tool = pdfAnnotationState.currentTool;

        ctx.strokeStyle = pdfAnnotationState.color;
        ctx.fillStyle = pdfAnnotationState.color;
        ctx.lineWidth = pdfAnnotationState.size;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        if (tool === 'rectangle') {
          ctx.strokeRect(
            Math.min(pdfAnnotationState.startX, x),
            Math.min(pdfAnnotationState.startY, y),
            Math.abs(x - pdfAnnotationState.startX),
            Math.abs(y - pdfAnnotationState.startY)
          );
        } else if (tool === 'circle') {
          const radius = Math.sqrt(Math.pow(x - pdfAnnotationState.startX, 2) + Math.pow(y - pdfAnnotationState.startY, 2));
          ctx.beginPath();
          ctx.arc(pdfAnnotationState.startX, pdfAnnotationState.startY, radius, 0, 2 * Math.PI);
          ctx.stroke();
        } else if (tool === 'line') {
          ctx.beginPath();
          ctx.moveTo(pdfAnnotationState.startX, pdfAnnotationState.startY);
          ctx.lineTo(x, y);
          ctx.stroke();
        } else if (tool === 'arrow') {
          drawArrowPdf(ctx, pdfAnnotationState.startX, pdfAnnotationState.startY, x, y);
        } else if (tool === 'star') {
          drawStarPdf(ctx, (pdfAnnotationState.startX + x) / 2, (pdfAnnotationState.startY + y) / 2, Math.abs(x - pdfAnnotationState.startX) / 2);
        } else if (tool === 'quarterNote') {
          const distance = Math.sqrt(Math.pow(x - pdfAnnotationState.startX, 2) + Math.pow(y - pdfAnnotationState.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          drawMusicSymbolPdf(ctx, pdfAnnotationState.startX, pdfAnnotationState.startY, '♩', size);
        } else if (tool === 'eighthNote') {
          const distance = Math.sqrt(Math.pow(x - pdfAnnotationState.startX, 2) + Math.pow(y - pdfAnnotationState.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          drawMusicSymbolPdf(ctx, pdfAnnotationState.startX, pdfAnnotationState.startY, '♪', size);
        } else if (tool === 'beamedEighth') {
          const distance = Math.sqrt(Math.pow(x - pdfAnnotationState.startX, 2) + Math.pow(y - pdfAnnotationState.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          drawMusicSymbolPdf(ctx, pdfAnnotationState.startX, pdfAnnotationState.startY, '♫', size);
        } else if (tool === 'beamedSixteenth') {
          const distance = Math.sqrt(Math.pow(x - pdfAnnotationState.startX, 2) + Math.pow(y - pdfAnnotationState.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          drawMusicSymbolPdf(ctx, pdfAnnotationState.startX, pdfAnnotationState.startY, '♬', size);
        } else if (tool === 'flat') {
          const distance = Math.sqrt(Math.pow(x - pdfAnnotationState.startX, 2) + Math.pow(y - pdfAnnotationState.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          drawMusicSymbolPdf(ctx, pdfAnnotationState.startX, pdfAnnotationState.startY, '♭', size);
        } else if (tool === 'natural') {
          const distance = Math.sqrt(Math.pow(x - pdfAnnotationState.startX, 2) + Math.pow(y - pdfAnnotationState.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          drawMusicSymbolPdf(ctx, pdfAnnotationState.startX, pdfAnnotationState.startY, '♮', size);
        } else if (tool === 'sharp') {
          const distance = Math.sqrt(Math.pow(x - pdfAnnotationState.startX, 2) + Math.pow(y - pdfAnnotationState.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          drawMusicSymbolPdf(ctx, pdfAnnotationState.startX, pdfAnnotationState.startY, '♯', size);
        } else if (tool === 'trebleClef') {
          const distance = Math.sqrt(Math.pow(x - pdfAnnotationState.startX, 2) + Math.pow(y - pdfAnnotationState.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          drawMusicSymbolPdf(ctx, pdfAnnotationState.startX, pdfAnnotationState.startY, '𝄞', size);
        } else if (tool === 'bassClef') {
          const distance = Math.sqrt(Math.pow(x - pdfAnnotationState.startX, 2) + Math.pow(y - pdfAnnotationState.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          drawMusicSymbolPdf(ctx, pdfAnnotationState.startX, pdfAnnotationState.startY, '𝄢', size);
        }

        pdfAnnotationState.isDrawing = false;
      }

      function drawArrowPdf(ctx, x1, y1, x2, y2) {
        const headlen = 15;
        const angle = Math.atan2(y2 - y1, x2 - x1);

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
        ctx.closePath();
        ctx.fill();
      }

      function drawStarPdf(ctx, centerX, centerY, radius) {
        const points = 5;
        const innerRadius = radius / 2;
        ctx.beginPath();
        for (let i = 0; i < points * 2; i++) {
          const angle = (i * Math.PI) / points - Math.PI / 2;
          const r = i % 2 === 0 ? radius : innerRadius;
          const x = centerX + r * Math.cos(angle);
          const y = centerY + r * Math.sin(angle);
          if (i === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        }
        ctx.closePath();
        ctx.stroke();
      }

      function drawMusicSymbolPdf(ctx, x, y, symbol, size = 40) {
        ctx.fillStyle = pdfAnnotationState.color;
        ctx.font = `bold ${size}px Arial, sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(symbol, x, y);
      }

      function floodFillPdf(canvas, x, y, fillColor) {
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const width = imageData.width;
        const height = imageData.height;

        // Helper functions
        const getPixel = (idx) => [data[idx], data[idx + 1], data[idx + 2], data[idx + 3]];
        const getIdx = (px, py) => (py * width + px) * 4;
        const isBoundary = (idx) => {
          const [r, g, b, a] = getPixel(idx);
          // Consider dark/opaque pixels as boundaries (the drawn strokes)
          return a > 200 && (r < 100 || g < 100 || b < 100);
        };

        const startIdx = getIdx(Math.floor(x), Math.floor(y));
        const [startR, startG, startB, startA] = getPixel(startIdx);

        // If clicking on a boundary, don't fill
        if (isBoundary(startIdx)) return;

        const fillRGB = hexToRgbPdf(fillColor);
        const stack = [[Math.floor(x), Math.floor(y)]];
        const visited = new Set();

        while (stack.length > 0) {
          const [cx, cy] = stack.pop();
          if (cx < 0 || cx >= width || cy < 0 || cy >= height) continue;

          const key = `${cx},${cy}`;
          if (visited.has(key)) continue;
          visited.add(key);

          const idx = getIdx(cx, cy);
          const [pr, pg, pb, pa] = getPixel(idx);

          // Stop at boundaries (drawn lines)
          if (isBoundary(idx)) continue;

          // Only fill if similar to start color (typically white/empty inside shapes)
          const diff = Math.sqrt((pr - startR) ** 2 + (pg - startG) ** 2 + (pb - startB) ** 2);
          if (diff > 50) continue;

          data[idx] = fillRGB.r;
          data[idx + 1] = fillRGB.g;
          data[idx + 2] = fillRGB.b;
          data[idx + 3] = 255;

          stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
        }

        ctx.putImageData(imageData, 0, 0);
      }

      function hexToRgbPdf(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
      }

      function handlePdfTextInput(canvas, x, y) {
        const textInput = document.createElement('textarea');
        textInput.style.cssText = `
      position: fixed;
      left: ${x + 280}px;
      top: ${y + 64}px;
      width: 150px;
      height: 60px;
      padding: 8px;
      background: rgba(255, 255, 255, 0.95);
      color: #000;
      border: 2px solid ${pdfAnnotationState.color};
      border-radius: 4px;
      font-size: 14px;
      font-family: ${pdfAnnotationState.textFont};
      z-index: 9999;
      resize: both;
    `;

        document.body.appendChild(textInput);
        textInput.focus();

        const finishText = () => {
          const text = textInput.value;
          if (text) {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = pdfAnnotationState.color;
            const fontWeight = pdfAnnotationState.textBold ? 'bold' : 'normal';
            const fontStyle = pdfAnnotationState.textItalic ? 'italic' : 'normal';
            const font = `${fontWeight} ${fontStyle} ${pdfAnnotationState.textSize}px ${pdfAnnotationState.textFont}`;
            ctx.font = font;

            const lines = text.split('\n');
            let currentY = y;
            lines.forEach(line => {
              ctx.fillText(line, x, currentY);
              currentY += pdfAnnotationState.textSize + 5;
            });

            savePdfAnnotationState();
          }
          textInput.remove();
        };

        textInput.addEventListener('blur', finishText);
        textInput.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            textInput.remove();
          }
        });
      }

      function savePdfAnnotationState() {
        pdfAnnotationState.redoHistory = [];
        const canvasStates = pdfAnnotationState.canvases.map(canvas => {
          const wrapper = canvas.parentElement;
          const annotCanvas = wrapper?.querySelector('.pdf-annotation-layer');
          return annotCanvas ? annotCanvas.toDataURL() : null;
        });
        pdfAnnotationState.history.push(canvasStates);
        if (pdfAnnotationState.history.length > 20) {
          pdfAnnotationState.history.shift();
        }
        // Update button states when annotation is saved
        updatePdfUndoButtonState();
        updatePdfRedoButtonState();
      }

      function restorePdfAnnotationState(states) {
        if (!states) return;
        pdfAnnotationState.canvases.forEach((canvas, idx) => {
          const wrapper = canvas.parentElement;
          const annotCanvas = wrapper?.querySelector('.pdf-annotation-layer');
          if (annotCanvas && states[idx]) {
            const img = new Image();
            img.onload = () => {
              const ctx = annotCanvas.getContext('2d');
              ctx.clearRect(0, 0, annotCanvas.width, annotCanvas.height);
              ctx.drawImage(img, 0, 0);
            };
            img.src = states[idx];
          }
        });
      }

      function updatePdfRedoButtonState() {
        const redoBtn = $('#pdfRedoAnnotations');
        if (redoBtn) {
          redoBtn.disabled = pdfAnnotationState.redoHistory.length === 0;
          redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';
        }
      }

      function updatePdfUndoButtonState() {
        const undoBtn = $('#pdfUndoAnnotations');
        if (undoBtn) {
          // Disable undo if history only has the initial empty state or is empty
          undoBtn.disabled = pdfAnnotationState.history.length <= 1;
          undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';
        }
      }

      function clearAllPdfAnnotations(withConfirm = true) {
        if (withConfirm && !confirm('Clear all PDF annotations?')) return;

        pdfAnnotationState.canvases.forEach(canvas => {
          const wrapper = canvas.parentElement;
          const annotCanvas = wrapper?.querySelector('.pdf-annotation-layer');
          if (annotCanvas) {
            const ctx = annotCanvas.getContext('2d');
            ctx.clearRect(0, 0, annotCanvas.width, annotCanvas.height);
          }
        });
        pdfAnnotationState.history = [];
        pdfAnnotationState.redoHistory = [];
      }

      function savePdfAnnotations() {
        try {
          const container = $('#pdfContainer');
          if (!container) {
            alert('PDF not loaded');
            return;
          }

          // Find pages with annotations
          const pageWrappers = Array.from(container.querySelectorAll('.pdf-page'));
          if (pageWrappers.length === 0) {
            alert('No PDF pages found');
            return;
          }

          // Find first page with annotations
          let firstPageWithAnnotations = null;
          for (let wrapper of pageWrappers) {
            const annotCanvas = wrapper.querySelector('.pdf-annotation-layer');
            if (annotCanvas) {
              const ctx = annotCanvas.getContext('2d');
              const imageData = ctx.getImageData(0, 0, annotCanvas.width, annotCanvas.height);
              // Check if canvas has any non-transparent pixels
              if (imageData.data.some((val, idx) => idx % 4 === 3 && val > 0)) {
                firstPageWithAnnotations = wrapper;
                break;
              }
            }
          }

          if (!firstPageWithAnnotations) {
            alert('No annotations found on PDF');
            return;
          }

          // Get both the PDF canvas and annotation canvas
          const pdfCanvas = firstPageWithAnnotations.querySelector('canvas:not(.pdf-annotation-layer)');
          const annotCanvas = firstPageWithAnnotations.querySelector('.pdf-annotation-layer');

          if (!pdfCanvas || !annotCanvas) {
            alert('Could not find PDF or annotation layer');
            return;
          }

          // Create composite canvas
          const compositeCanvas = document.createElement('canvas');
          const compositeCtx = compositeCanvas.getContext('2d');

          compositeCanvas.width = pdfCanvas.width;
          compositeCanvas.height = pdfCanvas.height;

          // Draw PDF first
          const pdfImg = new Image();
          pdfImg.onload = () => {
            compositeCtx.drawImage(pdfImg, 0, 0);

            // Draw annotations on top
            const annotImg = new Image();
            annotImg.onload = () => {
              compositeCtx.drawImage(annotImg, 0, 0);

              // Download composite
              const link = document.createElement('a');
              link.href = compositeCanvas.toDataURL('image/png');
              link.download = `pdf-with-annotations-${new Date().getTime()}.png`;
              link.click();
              log('PDF with annotations saved as PNG');
            };
            annotImg.src = annotCanvas.toDataURL('image/png');
          };
          pdfImg.src = pdfCanvas.toDataURL('image/png');

        } catch (err) {
          console.error('Save error:', err);
          alert('Error saving annotations: ' + err.message);
        }
      }

      async function showPdfFromBuffer(buf, fileName) {
        try {
          if (at && typeof at.stop === 'function') at.stop();
          if (at && typeof at.pause === 'function') at.pause();
          at.timePosition = 0;

          // Don't destroy - just clear state so player is ready for next score
          if (at?.player && typeof at.player.stop === 'function') {
            at.player.stop();
          }
        } catch (e) { }

        // Clear the AlphaTab score and audio state completely
        try {
          // Stop all playback
          if (at?.player) {
            if (typeof at.player.stop === 'function') {
              at.player.stop();
            }
            // Reset the synthesizer by stopping all voices
            if (at.player.soundFont && typeof at.player.soundFont.stopAllVoices === 'function') {
              at.player.soundFont.stopAllVoices();
            }
          }

          // Clear score
          at.score = null;
          at.tracks = [];
          at.playbackRange = null;
          at.isLooping = false;

          if (at?.player) {
            if (typeof at.player.clearPlaybackRange === 'function') {
              at.player.clearPlaybackRange();
            }
            at.player.isLooping = false;
          }

          // Mute master volume temporarily
          if (at?.player?.masterVolume !== undefined) {
            at.player.masterVolume = 0;
          }
        } catch (e) { console.log('Clear error:', e); }

        const host = atContainer();
        if (host) {
          const oldOverlay = host.querySelector('.pdf-overlay');
          if (oldOverlay) {
            oldOverlay.remove();
          }
        }

        ensurePdfOverlay();
        const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
        pdfState.pdf = pdf;
        attachToolbarHandlers();
        await renderAllPages();

        // Initialize PDF annotation system
        const pdfContainer = $('#pdfContainer');
        if (pdfContainer) {
          initPdfAnnotations(pdfContainer);
        }

        if (metaBox()) metaBox().textContent = (fileName || 'PDF Sheet');

        AppState.isPlaying = false;
        updateButtonStates();

        const tracksContainer = $('#tracks');
        if (tracksContainer) {
          tracksContainer.innerHTML = '';
        }

        log(`📄 PDF loaded: ${fileName || 'Document'}`);
      }

      function interceptPdfOnFileInput() {
        const input = $('#fileInput');
        if (!input) return;
        input.addEventListener('change', async function (e) {
          try {
            const f = e.target.files?.[0];
            if (!f) return;
            if (!/\.pdf$/i.test(f.name)) return;

            e.stopImmediatePropagation();
            e.preventDefault();

            const buf = await f.arrayBuffer();
            await showPdfFromBuffer(buf, f.name);

            const auto = $('#autoScroll');
            if (auto && auto.checked) {
              auto.checked = false;
              auto.dispatchEvent(new Event('change'));
            }
          } catch (err) {
            console.error('PDF load error:', err);
            alert('Could not load PDF: ' + (err?.message || err));
          }
        }, true);
      }

      // Clean up PDF mode when loading non-PDF files
      $('#fileInput')?.addEventListener('change', function (e) {
        try {
          const f = e.target.files?.[0];
          if (!f) return;
          if (/\.pdf$/i.test(f.name)) return;

          const host = $('#alphaTab');
          if (!host) return;
          if (host.classList.contains('pdf-mode')) {
            host.classList.remove('pdf-mode');
            const overlay = host.querySelector('.pdf-overlay');
            const _btn = $('#pdfScrollToggle');
            if (_btn && _btn.textContent.indexOf('⸏') !== -1) _btn.click();
            if (overlay) overlay.remove();
            const wrap = host.closest('.wrap');
            if (wrap) wrap.classList.remove('pdf-active');

            // Reset PDF annotation state
            pdfAnnotationState.currentTool = null;
            pdfAnnotationState.canvases = [];
            pdfAnnotationState.isDrawing = false;
            const drawBtn = $('#pdfDrawTool');
            const highlightBtn = $('#pdfHighlightTool');
            if (drawBtn) drawBtn.classList.remove('active');
            if (highlightBtn) highlightBtn.classList.remove('active');
          }
        } catch (err) { console.warn('precleanup error', err); }
      }, true);

      window.addEventListener('resize', function () {
        const host = atContainer();
        if (!host || !host.classList.contains('pdf-mode') || !pdfState.pdf) return;
        renderAllPages();
      }, { passive: true });

      interceptPdfOnFileInput();
    })();

    // ====== SONG SEARCH MODAL ======
    (function () {
      const DEFAULT_LIBRARY = [
        // { title: "Canon in D", artist: "Pachelbel", url: "https://cdn.jsdelivr.net/gh/gleitz/midi-js-soundfonts/examples/midi/CanoninD.mid", type: "midi", tags: "classical wedding piano" },
        // { title: "Fur Elise", artist: "Beethoven", url: "https://cdn.jsdelivr.net/gh/gleitz/midi-js-soundfonts/examples/midi/FurElise.mid", type: "midi", tags: "classical piano" },
        // { title: "Greensleeves", artist: "Traditional", url: "https://cdn.jsdelivr.net/gh/gleitz/midi-js-soundfonts/examples/midi/greensleeves.mid", type: "midi", tags: "folk guitar" }
      ];

      async function getLibrary() {
        if (Array.isArray(window.UPKRAFT_SONGS) && window.UPKRAFT_SONGS.length) return window.UPKRAFT_SONGS;
        try {
          const res = await fetch('/songs.json', { cache: 'no-store' });
          if (res.ok) {
            const data = await res.json();
            if (Array.isArray(data) && data.length) return data;
          }
        } catch (e) { /* ignore */ }
        return DEFAULT_LIBRARY;
      }

      function openModal() {
        const m = $('#songSearchModal');
        if (!m) return;
        m.style.display = 'block';
        m.setAttribute('aria-hidden', 'false');
        setTimeout(() => $('#songSearchInput')?.focus(), 50);
      }

      function closeModal() {
        const m = $('#songSearchModal');
        if (!m) return;
        m.style.display = 'none';
        m.setAttribute('aria-hidden', 'true');
      }

  async function renderResults(query){
    const box = $('#songResults');
    box.innerHTML = '<div class="loading">Searching...</div>';

    try{
      let results = [];
      const q = (query||'').trim();
      if (q) {
        const apiUrl = (p) => {
          const base = (window.UPKRAFT_API_BASE || window.API_BASE_URL || '').replace(/\/+$/, '');
          const path = p.startsWith('/') ? p : `/${p}`;
          return base ? `${base}${path}` : path;
        };
        const res = await fetch(apiUrl(`/Api/songs/search?q=${encodeURIComponent(q)}`));
        if (!res.ok) throw new Error('Search API failed');
        const data = await res.json();
        results = Array.isArray(data?.items) ? data.items : [];
      } else {
        const lib = await getLibrary();
        results = Array.isArray(lib) ? lib : [];
      }

      box.innerHTML = '';
      if (results.length === 0) {
        box.innerHTML = '<div class="no-results">No songs found</div>';
        return;
      }

      results.forEach((s, idx)=>{
        const div = document.createElement('div');
        div.className = 'song-result';
        div.setAttribute('role','option');
        div.dataset.index = String(idx);
        div.innerHTML = '<div class="title">'+ (s.title||'Untitled') +'</div>' +
                        '<div class="meta">'+ (s.artist||'') +' · '+ (s.type||'file') +'</div>';
        div.addEventListener('click', ()=> loadSong(s));
        box.appendChild(div);
      });
      const first = box.querySelector('.song-result');
      if (first) first.setAttribute('aria-selected','true');
    } catch(err){
      console.error('Search error:', err);
      box.innerHTML = '<div class="error">Search failed</div>';
    }
  }
  
  async function loadSong(song) {
  try {
    const url = song.url;
    if (!url) throw new Error('No song URL provided');

    const ext = url.split('.').pop().toLowerCase();

    // Fetch the file
    const apiUrl = (p) => {
      const base = (window.UPKRAFT_API_BASE || window.API_BASE_URL || '').replace(/\/+$/, '');
      const path = p.startsWith('/') ? p : `/${p}`;
      return base ? `${base}${path}` : path;
    };
    const res = await fetch(url.startsWith('http') ? url : apiUrl(url));
    if (!res.ok) throw new Error('Failed to fetch file: ' + res.status);

    const buf = await res.arrayBuffer();

    if (ext === 'pdf') {
      // ✅ Call PDF loader
      await showPdfFromBuffer(buf, song.title || url);
    } else {
      // ✅ Use AlphaTab for GP/GPX/MusicXML files
      if (!window.at) throw new Error('AlphaTab not ready');
      await window.at.load(buf);
    }

    // Update meta info
    const meta = document.getElementById('meta');
    if (meta) meta.textContent = `${song.title || 'Song'} — ${song.artist || ''}`;

    closeModal();
    
    // Auto-play after loading
    // setTimeout(() => document.getElementById('play')?.click(), 300);

  } catch (e) {
    console.error(e);
    alert('Could not load song: ' + e.message);
  }
}

      $('#searchSong')?.addEventListener('click', openModal);
      $('#songModalClose')?.addEventListener('click', closeModal);
      $('#songModalCancel')?.addEventListener('click', closeModal);
      $('.song-modal-backdrop')?.addEventListener('click', closeModal);

      const input = $('#songSearchInput');
      input?.addEventListener('input', (e) => renderResults(e.target.value));

      document.addEventListener('keydown', (e) => {
        const modalVisible = $('#songSearchModal')?.getAttribute('aria-hidden') === 'false';
        if (!modalVisible) return;

        const items = $$('#songResults .song-result');
        if (!items.length) return;
        let idx = items.findIndex(x => x.getAttribute('aria-selected') === 'true');
        if (idx < 0) idx = 0;

        if (e.key === 'ArrowDown') {
          e.preventDefault();
          items[idx].removeAttribute('aria-selected');
          const ni = Math.min(items.length - 1, idx + 1);
          items[ni].setAttribute('aria-selected', 'true');
          items[ni].scrollIntoView({ block: 'nearest' });
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          items[idx].removeAttribute('aria-selected');
          const pi = Math.max(0, idx - 1);
          items[pi].setAttribute('aria-selected', 'true');
          items[pi].scrollIntoView({ block: 'nearest' });
        } else if (e.key === 'Enter') {
          e.preventDefault();
          const sel = items.find(x => x.getAttribute('aria-selected') === 'true') || items[0];
          const libIndex = Number(sel.dataset.index) || 0;
          getLibrary().then(lib => loadSong(lib[libIndex]));
        } else if (e.key === 'Escape') {
          closeModal();
        }
      });

      $('#searchSong')?.addEventListener('click', () => renderResults(''));
    })();

    // ====== THEME TOGGLE ======
    (function () {
      const root = document.documentElement;
      const btn = $('#toggleTheme');
      const saved = localStorage.getItem('upkraft-theme');

      function setTheme(next) {
        root.setAttribute('data-theme', next);
        localStorage.setItem('upkraft-theme', next);
        if (btn) {
          const icon = btn.querySelector('.theme-icon');
          if (icon) icon.textContent = next === 'dark' ? '🌙' : '☀️';
        }
      }
      if (saved) { setTheme(saved); } else { setTheme('dark'); }

      if (btn) {
        btn.addEventListener('click', () => {
          const cur = root.getAttribute('data-theme') || 'dark';
          setTheme(cur === 'dark' ? 'light' : 'dark');
        });
      }
    })();

    // ====== TREBLE CLEF TOGGLE ======
    (function () {
      const btn = $('#toggleTreble');
      if (!btn || !at || !window.alphaTab) return;

      let trebleOn = true;
      btn.textContent = "Treble Clef";
      btn.classList.add('active');
      btn.addEventListener('click', function () {
        trebleOn = !trebleOn;
        btn.textContent = "Treble Clef";
        btn.classList.toggle('active', trebleOn);
        try {
          const wasPlaying = AppState.isPlaying;
          const currentMs = at.timePosition || 0;
          const currentTracks = (at.tracks?.length)
            ? at.tracks
            : (at.score?.tracks?.length ? [at.score.tracks[0]] : []);

          at.settings.display.staveProfile = trebleOn
            ? alphaTab.StaveProfile.ScoreTab
            : alphaTab.StaveProfile.Tab;

          at.updateSettings();
          if (currentTracks.length) {
            at.renderTracks(currentTracks);
          }

          if (wasPlaying) {
            at.stop();
            at.timePosition = currentMs;
            at.play();
          }
        } catch (e) {
          console.log("Treble toggle failed:", e);
        }
      }, { passive: true });
    })();

    // ====== INITIALIZATION ON DOM READY ======
    document.addEventListener('DOMContentLoaded', () => {

      // Start auto-follow
      requestAnimationFrame(autoFollowPlayhead);

      // Align UI elements
      setTimeout(alignUIElements, 100);
      window.addEventListener('resize', alignUIElements);

      // Initial button states
      updateButtonStates();

        // Auto-load selected song if provided via query
  try {
    var sel = window.__UPKRAFT_SELECTED_SONG__;
    if (sel) {
      var apiUrl = function(p){
        var base = (window.UPKRAFT_API_BASE || window.API_BASE_URL || '').replace(/\/+$/, '');
        var path = p.startsWith('/') ? p : '/' + p;
        return base ? (base + path) : path;
      };
      var url = /^https?:\/\//i.test(sel) ? sel : apiUrl(sel);
      console.log('[Visualizer] Auto-loading selected song:', { sel, resolved: url, apiBase: (window.UPKRAFT_API_BASE || window.API_BASE_URL || '') });
      // Reuse loadSong's logic pathway
      loadSong({ title: 'Selected Song', artist: '', url }).catch(function(err){
        console.error('[Visualizer] Auto-load failed:', err);
        alert('Could not auto-load song: ' + (err && err.message ? err.message : err));
      });
    }
  } catch(_){}
  // Also support dynamic selection via postMessage from parent
  window.addEventListener('message', function(e){
    try{
      if (e && e.data && e.data.type === 'upkraft:loadSong' && e.data.url){
        var base = (window.UPKRAFT_API_BASE || window.API_BASE_URL || '').replace(/\/+$/, '');
        var url = /^https?:\/\//i.test(e.data.url) ? e.data.url : (base ? base + (e.data.url.startsWith('/') ? e.data.url : '/' + e.data.url) : e.data.url);
        loadSong({ title: 'Selected Song', url: url });
      }
    }catch(err){ console.warn('postMessage loadSong failed', err); }
  });
    });

    // ====== ANNOTATION SYSTEM ======
    class SheetAnnotation {
      constructor(canvasId, mainContainer) {
        this.canvas = document.getElementById(canvasId);
        this.mainContainer = mainContainer;
        this.ctx = this.canvas.getContext('2d');

        this.tool = 'pen';
        this.color = '#ff0000';
        this.brushSize = 3;
        this.isDrawing = false;
        this.startX = 0;
        this.startY = 0;
        this.history = [];
        this.enabled = false;

        this.setupCanvas();
        this.attachEvents();
      }

      setupCanvas() {
        const host = this.mainContainer || document.getElementById('alphaTab');
        if (!host) return;
        if (!this.canvas) {
          this.canvas = document.getElementById('annotationCanvas') || document.createElement('canvas');
          this.canvas.id = 'annotationCanvas';
        }
        if (!this.ctx) this.ctx = this.canvas.getContext('2d');
        const w = host.scrollWidth || host.clientWidth;
        const h = host.scrollHeight || host.clientHeight;
        this.canvas.width = Math.max(1, w);
        this.canvas.height = Math.max(1, h);
        this.canvas.style.position = 'absolute';
        this.canvas.style.top = '0px';
        this.canvas.style.left = '0px';
        this.canvas.style.zIndex = '3';
        this.canvas.style.pointerEvents = 'auto';
        if (this.canvas.parentNode !== host) host.appendChild(this.canvas);
        this.ctx.lineCap = 'round';
        this.ctx.lineJoin = 'round';
      }

      attachEvents() {
        ['pen', 'highlight', 'arrow', 'circle', 'text', 'eraser', 'fill'].forEach(tool => {
          const btn = document.getElementById(tool + 'Tool');
          if (btn) btn.addEventListener('click', () => this.selectTool(tool));
        });

        // Add event listeners for shape buttons in dropdown
        ['rectangle', 'line', 'star', 'quarterNote', 'eighthNote', 'beamedEighth', 'beamedSixteenth', 'flat', 'natural', 'sharp', 'trebleClef', 'bassClef'].forEach(shape => {
          const btn = document.getElementById(shape + 'Tool');
          if (btn) btn.addEventListener('click', () => this.selectTool(shape));
        });

        const colorPicker = document.getElementById('annotationColor');
        if (colorPicker) colorPicker.addEventListener('change', (e) => {
          this.color = e.target.value;
        });

        const sizeSel = document.getElementById('annotationSize');
        if (sizeSel) sizeSel.addEventListener('input', (e) => {
          this.brushSize = parseInt(e.target.value);
          document.getElementById('sizeDisplay').textContent = this.brushSize;
        });

        document.getElementById('undoAnnotation')?.addEventListener('click', () => this.undo());
        document.getElementById('redoAnnotation')?.addEventListener('click', () => this.redo());
        document.getElementById('clearAnnotations')?.addEventListener('click', () => this.clear());
        document.getElementById('saveWithSheet')?.addEventListener('click', () => this.handleSave());

        // Initialize button states
        this.updateUndoButtonState();
        this.updateRedoButtonState();

        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
        this.canvas.addEventListener('mouseleave', () => {
          if (this.isDrawing && (this.tool === 'pen' || this.tool === 'eraser')) {
            this.saveState();
          }
          this.isDrawing = false;
        });
        // Allow scrolling through canvas when not drawing
        this.canvas.addEventListener('wheel', (e) => {
          if (this.isDrawing) e.preventDefault(); // allow native scroll when not drawing
        });

        // Add AFTER existing mouse events (around line 5605):

        this.canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousedown', {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          this.onMouseDown(mouseEvent);
        });

        this.canvas.addEventListener('touchmove', (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          const mouseEvent = new MouseEvent('mousemove', {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          this.onMouseMove(mouseEvent);
        });

        this.canvas.addEventListener('touchend', (e) => {
          e.preventDefault();
          const touch = e.changedTouches[0];
          const mouseEvent = new MouseEvent('mouseup', {
            clientX: touch.clientX,
            clientY: touch.clientY
          });
          this.onMouseUp(mouseEvent);
        });

        this.canvas.addEventListener('touchcancel', (e) => {
          this.isDrawing = false;
        });

        window.addEventListener('resize', () => {
          if (this.enabled) {
            this.setupCanvas();
          }
        });
      }

      selectTool(toolName) {
        this.tool = toolName;
        document.querySelectorAll('#annotationPanel .tool-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(toolName + 'Tool').classList.add('active');
        this.canvas.style.cursor = 'crosshair';
      }

      onMouseDown(e) {
        if (!this.enabled) return;
        const rect = this.canvas.getBoundingClientRect();
        this.startX = e.clientX - rect.left;
        this.startY = e.clientY - rect.top;
        this.isDrawing = true;

        // Save canvas state for shape preview
        this.canvasSnapshot = this.canvas.toDataURL();

        // Handle fill tool - execute immediately on click
        if (this.tool === 'fill') {
          this.floodFill(this.startX, this.startY, this.color);
          this.isDrawing = false;
          return;
        }
      }

      onMouseMove(e) {
        if (!this.isDrawing || !this.enabled) return;

        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (this.tool === 'pen') {
          this.drawStraightLine(this.startX, this.startY, x, y);
          this.startX = x;
          this.startY = y;
        } else if (this.tool === 'eraser') {
          this.eraserMode(x, y);
        } else if (['rectangle', 'circle', 'arrow', 'line', 'star', 'highlight', 'quarterNote', 'eighthNote', 'beamedEighth', 'beamedSixteenth', 'flat', 'natural', 'sharp', 'trebleClef', 'bassClef'].includes(this.tool)) {
          // Shape preview - restore canvas and draw preview
          if (this.canvasSnapshot) {
            const img = new Image();
            img.onload = () => {
              this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
              this.ctx.drawImage(img, 0, 0);

              // Draw preview with transparency
              this.ctx.globalAlpha = 0.6;

              if (this.tool === 'rectangle') {
                this.ctx.strokeStyle = this.color;
                this.ctx.lineWidth = this.brushSize;
                this.ctx.strokeRect(Math.min(this.startX, x), Math.min(this.startY, y), Math.abs(x - this.startX), Math.abs(y - this.startY));
              } else if (this.tool === 'circle') {
                const radius = Math.sqrt(Math.pow(x - this.startX, 2) + Math.pow(y - this.startY, 2));
                this.ctx.strokeStyle = this.color;
                this.ctx.lineWidth = this.brushSize;
                this.ctx.beginPath();
                this.ctx.arc(this.startX, this.startY, radius, 0, 2 * Math.PI);
                this.ctx.stroke();
              } else if (this.tool === 'line') {
                this.ctx.strokeStyle = this.color;
                this.ctx.lineWidth = this.brushSize;
                this.ctx.beginPath();
                this.ctx.moveTo(this.startX, this.startY);
                this.ctx.lineTo(x, y);
                this.ctx.stroke();
              } else if (this.tool === 'arrow') {
                this.drawArrow(this.startX, this.startY, x, y);
              } else if (this.tool === 'star') {
                this.drawStar(this.startX, this.startY, x, y);
              } else if (this.tool === 'highlight') {
                this.ctx.fillStyle = this.hexToRgba(this.color, 0.3);
                this.ctx.fillRect(Math.min(this.startX, x), Math.min(this.startY, y), Math.abs(x - this.startX), Math.abs(y - this.startY));
              } else if (['quarterNote', 'eighthNote', 'beamedEighth', 'beamedSixteenth', 'flat', 'natural', 'sharp', 'trebleClef', 'bassClef'].includes(this.tool)) {
                // Music symbol preview with size based on drag distance
                const distance = Math.sqrt(Math.pow(x - this.startX, 2) + Math.pow(y - this.startY, 2));
                const size = Math.max(20, Math.min(distance * 2, 150)); // Scale between 20px and 150px

                let symbol = '';
                if (this.tool === 'quarterNote') symbol = '♩';
                else if (this.tool === 'eighthNote') symbol = '♪';
                else if (this.tool === 'beamedEighth') symbol = '♫';
                else if (this.tool === 'beamedSixteenth') symbol = '♬';
                else if (this.tool === 'flat') symbol = '♭';
                else if (this.tool === 'natural') symbol = '♮';
                else if (this.tool === 'sharp') symbol = '♯';
                else if (this.tool === 'trebleClef') symbol = '𝄞';
                else if (this.tool === 'bassClef') symbol = '𝄢';

                this.drawMusicSymbol(this.startX, this.startY, symbol, size);
              }

              this.ctx.globalAlpha = 1.0;
            };
            img.src = this.canvasSnapshot;
          }
        }
      }

      onMouseUp(e) {
        if (!this.isDrawing) return;

        const rect = this.canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (this.tool === 'highlight') {
          this.drawHighlight(this.startX, this.startY, x, y);
        } else if (this.tool === 'arrow') {
          this.drawArrow(this.startX, this.startY, x, y);
        } else if (this.tool === 'circle') {
          this.drawCircle(this.startX, this.startY, x, y);
        } else if (this.tool === 'rectangle') {
          this.drawRectangle(this.startX, this.startY, x, y);
        } else if (this.tool === 'line') {
          this.drawStraightLine(this.startX, this.startY, x, y);
        } else if (this.tool === 'star') {
          this.drawStar(this.startX, this.startY, x, y);
        } else if (this.tool === 'quarterNote') {
          const distance = Math.sqrt(Math.pow(x - this.startX, 2) + Math.pow(y - this.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          this.drawMusicSymbol(this.startX, this.startY, '♩', size);
        } else if (this.tool === 'eighthNote') {
          const distance = Math.sqrt(Math.pow(x - this.startX, 2) + Math.pow(y - this.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          this.drawMusicSymbol(this.startX, this.startY, '♪', size);
        } else if (this.tool === 'beamedEighth') {
          const distance = Math.sqrt(Math.pow(x - this.startX, 2) + Math.pow(y - this.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          this.drawMusicSymbol(this.startX, this.startY, '♫', size);
        } else if (this.tool === 'beamedSixteenth') {
          const distance = Math.sqrt(Math.pow(x - this.startX, 2) + Math.pow(y - this.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          this.drawMusicSymbol(this.startX, this.startY, '♬', size);
        } else if (this.tool === 'flat') {
          const distance = Math.sqrt(Math.pow(x - this.startX, 2) + Math.pow(y - this.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          this.drawMusicSymbol(this.startX, this.startY, '♭', size);
        } else if (this.tool === 'natural') {
          const distance = Math.sqrt(Math.pow(x - this.startX, 2) + Math.pow(y - this.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          this.drawMusicSymbol(this.startX, this.startY, '♮', size);
        } else if (this.tool === 'sharp') {
          const distance = Math.sqrt(Math.pow(x - this.startX, 2) + Math.pow(y - this.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          this.drawMusicSymbol(this.startX, this.startY, '♯', size);
        } else if (this.tool === 'trebleClef') {
          const distance = Math.sqrt(Math.pow(x - this.startX, 2) + Math.pow(y - this.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          this.drawMusicSymbol(this.startX, this.startY, '𝄞', size);
        } else if (this.tool === 'bassClef') {
          const distance = Math.sqrt(Math.pow(x - this.startX, 2) + Math.pow(y - this.startY, 2));
          const size = Math.max(20, Math.min(distance * 2, 150));
          this.drawMusicSymbol(this.startX, this.startY, '𝄢', size);
        }

        this.isDrawing = false;
        // Save state after drawing is complete
        this.saveState();
      }

      drawStraightLine(x1, y1, x2, y2) {
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.brushSize;
        this.ctx.beginPath();
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();
      }

      drawHighlight(x1, y1, x2, y2) {
        this.ctx.fillStyle = this.hexToRgba(this.color, 0.3);
        this.ctx.fillRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
      }

      drawArrow(x1, y1, x2, y2) {
        const headlen = 15;
        const angle = Math.atan2(y2 - y1, x2 - x1);

        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.brushSize;
        this.ctx.beginPath();
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();

        this.ctx.beginPath();
        this.ctx.moveTo(x2, y2);
        this.ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
        this.ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
        this.ctx.closePath();
        this.ctx.fillStyle = this.color;
        this.ctx.fill();
      }

      drawCircle(x1, y1, x2, y2) {
        const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.brushSize;
        this.ctx.beginPath();
        this.ctx.arc(x1, y1, radius, 0, 2 * Math.PI);
        this.ctx.stroke();
      }

      drawLine(x1, y1, x2, y2) {
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.brushSize;
        this.ctx.beginPath();
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();
      }

      drawTriangle(x1, y1, x2, y2) {
        const centerX = (x1 + x2) / 2;
        const centerY = Math.min(y1, y2);
        const width = Math.abs(x2 - x1);
        const height = Math.abs(y2 - y1);

        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.brushSize;
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, centerY);
        this.ctx.lineTo(x1, centerY + height);
        this.ctx.lineTo(x2, centerY + height);
        this.ctx.closePath();
        this.ctx.stroke();
      }

      drawDiamond(x1, y1, x2, y2) {
        const centerX = (x1 + x2) / 2;
        const centerY = (y1 + y2) / 2;
        const width = Math.abs(x2 - x1) / 2;
        const height = Math.abs(y2 - y1) / 2;

        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.brushSize;
        this.ctx.beginPath();
        this.ctx.moveTo(centerX, centerY - height);
        this.ctx.lineTo(centerX + width, centerY);
        this.ctx.lineTo(centerX, centerY + height);
        this.ctx.lineTo(centerX - width, centerY);
        this.ctx.closePath();
        this.ctx.stroke();
      }

      drawStar(x1, y1, x2, y2) {
        const centerX = (x1 + x2) / 2;
        const centerY = (y1 + y2) / 2;
        const radius = Math.abs(x2 - x1) / 2;

        this.ctx.strokeStyle = this.color;
        this.ctx.fillStyle = this.color;
        this.ctx.lineWidth = this.brushSize;

        const points = 5;
        const innerRadius = radius / 2;
        this.ctx.beginPath();

        for (let i = 0; i < points * 2; i++) {
          const angle = (i * Math.PI) / points - Math.PI / 2;
          const r = i % 2 === 0 ? radius : innerRadius;
          const x = centerX + r * Math.cos(angle);
          const y = centerY + r * Math.sin(angle);
          if (i === 0) this.ctx.moveTo(x, y);
          else this.ctx.lineTo(x, y);
        }
        this.ctx.closePath();
        this.ctx.stroke();
      }

      drawMusicSymbol(x, y, symbol, size = 36) {
        this.ctx.fillStyle = this.color;
        this.ctx.font = `bold ${size}px Arial, sans-serif`;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        this.ctx.fillText(symbol, x, y);
      }

      drawRectangle(x1, y1, x2, y2) {
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = this.brushSize;
        this.ctx.strokeRect(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
      }

      eraserMode(x, y) {
        const eraserSize = this.brushSize * 3;
        this.ctx.clearRect(x - eraserSize / 2, y - eraserSize / 2, eraserSize, eraserSize);
        this.saveState();
      }

      hexToRgba(hex, alpha) {
        const r = parseInt(hex.slice(1, 3), 16);
        const g = parseInt(hex.slice(3, 5), 16);
        const b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
      }

      saveState() {
        this.redoHistory = []; // Clear redo history when new action is performed
        this.history.push(this.canvas.toDataURL());
        if (this.history.length > 20) this.history.shift();
        // Update button states when new state is saved
        this.updateUndoButtonState();
        this.updateRedoButtonState();
      }

      undo() {
        if (this.history.length === 0) return;  // Nothing to undo

        this.redoHistory = this.redoHistory || [];
        this.redoHistory.push(this.history.pop());

        if (this.history.length === 0) {
          // Last item was undone - clear canvas but DON'T clear redoHistory!
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        } else {
          // Restore previous state
          const img = new Image();
          img.src = this.history[this.history.length - 1];
          img.onload = () => {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.drawImage(img, 0, 0);
            // Update button states
            this.updateUndoButtonState();
            this.updateRedoButtonState();
          };
          return;  // Return early, button states updated in img.onload
        }

        // Update both undo and redo button states (for last item undo)
        this.updateUndoButtonState();
        this.updateRedoButtonState();
      }

      redo() {
        this.redoHistory = this.redoHistory || [];
        if (this.redoHistory.length === 0) return;

        const img = new Image();
        img.src = this.redoHistory[this.redoHistory.length - 1];
        img.onload = () => {
          this.history.push(this.redoHistory.pop());
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.ctx.drawImage(img, 0, 0);
          // Update both undo and redo button states
          this.updateUndoButtonState();
          this.updateRedoButtonState();
        };
      }

      updateRedoButtonState() {
        const redoBtn = document.getElementById('redoAnnotation');
        if (redoBtn) {
          redoBtn.disabled = !this.redoHistory || this.redoHistory.length === 0;
          redoBtn.style.opacity = redoBtn.disabled ? '0.5' : '1';
        }
      }

      updateUndoButtonState() {
        const undoBtn = document.getElementById('undoAnnotation');
        if (undoBtn) {
          undoBtn.disabled = !this.history || this.history.length === 0;
          undoBtn.style.opacity = undoBtn.disabled ? '0.5' : '1';
        }
      }

      clear() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.history = [this.canvas.toDataURL()];
        this.redoHistory = [];
        // Update button states when cleared
        this.updateUndoButtonState();
        this.updateRedoButtonState();
        log('Annotations cleared');
      }

save() {
  // Save annotations on white background when no sheet is loaded
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  
  canvas.width = this.canvas.width;
  canvas.height = this.canvas.height;
  
  // White background
  ctx.fillStyle = 'white';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Draw annotations on top
  const img = new Image();
  img.src = this.canvas.toDataURL('image/png');
  
  img.onload = () => {
    ctx.drawImage(img, 0, 0);
    const link = document.createElement('a');
    link.href = canvas.toDataURL('image/png');
    link.download = `annotations_${new Date().getTime()}.png`;
    link.click();
    log('Annotations saved on white background');
  };
  
  img.onerror = () => {
    alert('Error saving annotations');
  };
}

      isSheetLoaded() {
        // Check if sheet music is currently loaded
        const alphaTab = $('#alphaTab');
        if (!alphaTab) return false;
        
        const svgElements = alphaTab.querySelectorAll('svg');
        return svgElements.length > 0;
      }

      handleSave() {
        // Intelligent save: prompt for screenshot if sheet loaded, otherwise save to white background
        if (this.isSheetLoaded()) {
          this.promptScreenshot();
        } else {
          this.save();
        }
      }

      promptScreenshot() {
        const osType = navigator.platform.toLowerCase();
        const isWindows = osType.includes('win');
        const isMac = osType.includes('mac') || osType.includes('darwin');
        
        let tool = isWindows ? 'Snipping Tool' : isMac ? 'Screenshot' : 'Screenshot Tool';
        let instruction = isWindows 
          ? 'Press Win + Shift + S to open Snipping Tool'
          : isMac 
          ? 'Press Cmd + Shift + 4 to capture selected area'
          : 'Use your system screenshot utility';
        
        alert(`📸 Capture Sheet\n\n${instruction}\n\nPosition the annotation layer over your sheet music to capture both elements together.`);
        log(`Prompted user to use ${tool} for screenshot`);
      }

      saveWithSheet() {
        try {
          const alphaTab = $('#alphaTab');
          if (!alphaTab) {
            alert('Sheet not found');
            return;
          }

          log('Starting sheet capture...');

          // Get the full dimensions of the sheet
          const width = alphaTab.scrollWidth;
          const height = alphaTab.scrollHeight;

          // Create main canvas for the combined image
          const mainCanvas = document.createElement('canvas');
          const mainCtx = mainCanvas.getContext('2d');
          mainCanvas.width = width;
          mainCanvas.height = height;

          // White background
          mainCtx.fillStyle = 'white';
          mainCtx.fillRect(0, 0, width, height);

          // Get all SVG elements
          const svgElements = alphaTab.querySelectorAll('svg');

          if (svgElements.length === 0) {
            alert('No sheet music found');
            return;
          }

          // Convert all SVGs to images and draw them
          let processedCount = 0;
          const totalSvgs = svgElements.length;

          const finishCapture = () => {
            // Overlay annotations on top
            const annotationImageData = this.canvas.toDataURL();
            const annotationImg = new Image();
            annotationImg.src = annotationImageData;

            annotationImg.onload = () => {
              // Draw annotation canvas directly without scaling
              mainCtx.drawImage(annotationImg, 0, 0);

              // Download the combined result
              const link = document.createElement('a');
              link.href = mainCanvas.toDataURL('image/png');
              link.download = `sheet_with_annotations_${new Date().getTime()}.png`;
              link.click();

              log('Sheet with annotations saved successfully!');
            };

            annotationImg.onerror = () => {
              alert('Error processing annotations');
            };
          };

          // Process each SVG
          svgElements.forEach((svg, index) => {
            try {
              const svgString = new XMLSerializer().serializeToString(svg);
              const img = new Image();

              // Get the SVG's position
              const rect = svg.getBoundingClientRect();
              const alphaTabRect = alphaTab.getBoundingClientRect();
              const x = rect.left - alphaTabRect.left + alphaTab.scrollLeft;
              const y = rect.top - alphaTabRect.top + alphaTab.scrollTop;

              img.onload = () => {
                // Draw SVG at correct position with correct dimensions
                mainCtx.drawImage(
                  img,
                  x,
                  y,
                  svg.clientWidth,
                  svg.clientHeight
                );

                processedCount++;

                // When all SVGs are processed, add annotations
                if (processedCount === totalSvgs) {
                  setTimeout(finishCapture, 100);
                }
              };

              img.onerror = () => {
                console.error('Failed to load SVG:', index);
                processedCount++;

                if (processedCount === totalSvgs) {
                  setTimeout(finishCapture, 100);
                }
              };

              // Convert SVG to data URL
              img.src = 'data:image/svg+xml;base64,' +
                btoa(unescape(encodeURIComponent(svgString)));
            } catch (e) {
              console.error('Error processing SVG at index', index, e);
              processedCount++;

              if (processedCount === totalSvgs) {
                setTimeout(finishCapture, 100);
              }
            }
          });

        } catch (e) {
          console.error('Save error:', e);
          alert('Error saving sheet with annotations');
        }
      }

      floodFill(x, y, fillColor) {
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const data = imageData.data;
        const width = imageData.width;
        const height = imageData.height;

        // Get the color at clicked point
        const getPixel = (idx) => [data[idx], data[idx + 1], data[idx + 2], data[idx + 3]];
        const getIdx = (px, py) => (py * width + px) * 4;
        const isBoundary = (idx) => {
          const [r, g, b, a] = getPixel(idx);
          // Consider dark/opaque pixels as boundaries (the drawn strokes)
          return a > 200 && (r < 100 || g < 100 || b < 100);
        };

        const startIdx = getIdx(Math.floor(x), Math.floor(y));
        const [startR, startG, startB, startA] = getPixel(startIdx);

        // If clicking on a boundary, don't fill
        if (isBoundary(startIdx)) return;

        const fillRGB = this.hexToRgb(fillColor);
        const stack = [[Math.floor(x), Math.floor(y)]];
        const visited = new Set();

        while (stack.length > 0) {
          const [cx, cy] = stack.pop();
          if (cx < 0 || cx >= width || cy < 0 || cy >= height) continue;

          const key = `${cx},${cy}`;
          if (visited.has(key)) continue;
          visited.add(key);

          const idx = getIdx(cx, cy);
          const [pr, pg, pb, pa] = getPixel(idx);

          // Stop at boundaries (drawn lines)
          if (isBoundary(idx)) continue;

          // Only fill if similar to start color (typically white/empty inside shapes)
          const diff = Math.sqrt((pr - startR) ** 2 + (pg - startG) ** 2 + (pb - startB) ** 2);
          if (diff > 50) continue;

          data[idx] = fillRGB.r;
          data[idx + 1] = fillRGB.g;
          data[idx + 2] = fillRGB.b;
          data[idx + 3] = 255;

          stack.push([cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]);
        }

        this.ctx.putImageData(imageData, 0, 0);
        this.history.push(this.canvas.toDataURL());
        this.updateUndoButtonState();
      }

      hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : { r: 0, g: 0, b: 0 };
      }

      enable() {
        this.enabled = true;
        this.canvas.classList.add('active');
        this.setupCanvas();
        // Initialize history with empty canvas state
        if (this.history.length === 0) {
          this.history = [this.canvas.toDataURL()];
        }
      }

      disable() {
        this.enabled = false;
        this.canvas.classList.remove('active');
      }
    }

    // Initialize annotation system
    const annotationSystem = new SheetAnnotation('annotationCanvas', $('#alphaTab'));

    const toggleAnnotationBtn = $('#toggleAnnotations');
    const annotationPanel = $('#annotationPanel');

    // Keep annotation panel as a direct child of <body> so it sits at the top layer.
    (function () {
      try {
        const canvas = document.getElementById('annotationCanvas');
        const panel = document.getElementById('annotationPanel');

        // Position canvas as fixed overlay
        if (canvas) {
          canvas.style.position = 'fixed';
          canvas.style.top = '64px';
          canvas.style.left = '280px';
          canvas.style.zIndex = '2147483599';
          canvas.style.pointerEvents = 'auto';
        }

        if (panel && panel.parentNode !== document.body) {
          document.body.appendChild(panel);
          panel.style.position = 'fixed';
          panel.style.top = '64px';
          panel.style.right = '375px';
          panel.style.zIndex = '2147483600';
        }
      } catch (e) { console.warn('annotate top-layer init failed', e); }
    })();


    if (toggleAnnotationBtn) {
      toggleAnnotationBtn.addEventListener('click', () => {
        const alphaTab = $('#alphaTab');
        if (alphaTab && alphaTab.classList.contains('pdf-mode')) {
          alert('Use PDF annotation tools in the toolbar instead');
          return;
        }

        if (annotationSystem.enabled) {
          annotationSystem.disable();
          toggleAnnotationBtn.classList.remove('active');
          if (annotationPanel) annotationPanel.style.display = 'none';
          log('Annotation mode OFF');
          document.body.classList.remove('annotating');
        } else {
          annotationSystem.enable();
          toggleAnnotationBtn.classList.add('active');
          if (annotationPanel) {
            // Position panel directly under the Annotate button
            const rect = toggleAnnotationBtn.getBoundingClientRect();
            annotationPanel.style.display = 'block';
            annotationPanel.style.position = 'fixed';
            annotationPanel.style.top = (rect.bottom + 13) + 'px';  // 8px gap below button
            annotationPanel.style.right = 'auto';                  // Remove right positioning
            annotationPanel.style.left = (rect.left - 680) + 'px'; // Center-ish under button
          }
          log('Annotation mode ON');
          document.body.classList.add('annotating');
        }
      });
    }

    window.annotationSystem = annotationSystem;

    // Prevent clicks inside panel from closing it
    const panel = $('#annotationPanel');
    if (panel) {
      panel.addEventListener('click', (e) => {
        e.stopPropagation();
      });

      // Ensure all interactive elements in panel are clickable
      panel.querySelectorAll('button, input').forEach(el => {
        el.style.pointerEvents = 'auto';
      });
    }

    // Highlight active tool
    document.addEventListener('click', (e) => {
      if (e.target.id && e.target.id.endsWith('Tool')) {
        document.querySelectorAll('#annotationPanel .tool-btn').forEach(btn => {
          btn.classList.remove('active');
        });
        e.target.classList.add('active');
      }
    });

  </script>
  <!-- Recording Countdown Overlay -->
  <div id="recordCountdown" class="countdown-overlay" style="display:none;">
    <div class="countdown-content">
      <div class="countdown-number">5</div>
      <div class="countdown-text">Get Ready!</div>
      <button class="btn countdown-cancel">Cancel</button>
    </div>
  </div>

  <script>
    try {
      if (window.annotationSystem && typeof annotationSystem.setupCanvas === 'function') {
        window.addEventListener('resize', () => annotationSystem.setupCanvas());
        setTimeout(() => annotationSystem.setupCanvas(), 400);
      }
    } catch (e) { console.warn('setupCanvas hook fail', e); }
  </script>

</body>

</html>